#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import ai.chronon.api.common.ttypes
import ai.chronon.api.ttypes

from thrift.transport import TTransport
all_structs = []


class TabularDataType(object):
    EVENT = 1
    ENTITY = 2
    CUMULATIVE_EVENTS = 3

    _VALUES_TO_NAMES = {
        1: "EVENT",
        2: "ENTITY",
        3: "CUMULATIVE_EVENTS",
    }

    _NAMES_TO_VALUES = {
        "EVENT": 1,
        "ENTITY": 2,
        "CUMULATIVE_EVENTS": 3,
    }


class LogicalType(object):
    GROUP_BY = 1
    JOIN = 2
    STAGING_QUERY = 3
    MODEL = 4
    TABULAR_DATA = 5

    _VALUES_TO_NAMES = {
        1: "GROUP_BY",
        2: "JOIN",
        3: "STAGING_QUERY",
        4: "MODEL",
        5: "TABULAR_DATA",
    }

    _NAMES_TO_VALUES = {
        "GROUP_BY": 1,
        "JOIN": 2,
        "STAGING_QUERY": 3,
        "MODEL": 4,
        "TABULAR_DATA": 5,
    }


class GroupByNodeType(object):
    PARTIAL_IR = 1
    SAWTOOTH_IR = 2
    SNAPSHOT = 3
    PREPARE_UPLOAD = 10
    UPLOAD = 11
    STREAMING = 12

    _VALUES_TO_NAMES = {
        1: "PARTIAL_IR",
        2: "SAWTOOTH_IR",
        3: "SNAPSHOT",
        10: "PREPARE_UPLOAD",
        11: "UPLOAD",
        12: "STREAMING",
    }

    _NAMES_TO_VALUES = {
        "PARTIAL_IR": 1,
        "SAWTOOTH_IR": 2,
        "SNAPSHOT": 3,
        "PREPARE_UPLOAD": 10,
        "UPLOAD": 11,
        "STREAMING": 12,
    }


class JoinNodeType(object):
    BOOTSTRAP = 1
    RIGHT_PART = 2
    MERGE = 3
    BACKFILL = 4
    LABEL_PART = 5
    LABEL_JOIN = 6
    METADATA_UPLOAD = 20
    PREPARE_LOGS = 21
    SUMMARIZE = 40
    DRIFT = 41
    DRIFT_UPLOAD = 42

    _VALUES_TO_NAMES = {
        1: "BOOTSTRAP",
        2: "RIGHT_PART",
        3: "MERGE",
        4: "BACKFILL",
        5: "LABEL_PART",
        6: "LABEL_JOIN",
        20: "METADATA_UPLOAD",
        21: "PREPARE_LOGS",
        40: "SUMMARIZE",
        41: "DRIFT",
        42: "DRIFT_UPLOAD",
    }

    _NAMES_TO_VALUES = {
        "BOOTSTRAP": 1,
        "RIGHT_PART": 2,
        "MERGE": 3,
        "BACKFILL": 4,
        "LABEL_PART": 5,
        "LABEL_JOIN": 6,
        "METADATA_UPLOAD": 20,
        "PREPARE_LOGS": 21,
        "SUMMARIZE": 40,
        "DRIFT": 41,
        "DRIFT_UPLOAD": 42,
    }


class StagingQueryNodeType(object):
    BACKFILL = 1

    _VALUES_TO_NAMES = {
        1: "BACKFILL",
    }

    _NAMES_TO_VALUES = {
        "BACKFILL": 1,
    }


class ModelNodeType(object):
    TRAINING = 300
    BULK_INFERENCE = 301

    _VALUES_TO_NAMES = {
        300: "TRAINING",
        301: "BULK_INFERENCE",
    }

    _NAMES_TO_VALUES = {
        "TRAINING": 300,
        "BULK_INFERENCE": 301,
    }


class TableNodeType(object):
    MATERIALIZED = 1
    VIEW = 2

    _VALUES_TO_NAMES = {
        1: "MATERIALIZED",
        2: "VIEW",
    }

    _NAMES_TO_VALUES = {
        "MATERIALIZED": 1,
        "VIEW": 2,
    }


class NodeRunStatus(object):
    UNKNOWN = 0
    WAITING = 1
    RUNNING = 2
    SUCCEEDED = 3
    FAILED = 4

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "WAITING",
        2: "RUNNING",
        3: "SUCCEEDED",
        4: "FAILED",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "WAITING": 1,
        "RUNNING": 2,
        "SUCCEEDED": 3,
        "FAILED": 4,
    }


class TabularData(object):
    """
    Represents a group of structured data assets that the same data flows through
    just a normalized version of Events + Entity sources.


    Attributes:
     - table
     - topic
     - mutationTable
     - type

    """


    def __init__(self, table=None, topic=None, mutationTable=None, type=None,):
        self.table = table
        self.topic = topic
        self.mutationTable = mutationTable
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.topic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mutationTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TabularData')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 1)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.topic is not None:
            oprot.writeFieldBegin('topic', TType.STRING, 2)
            oprot.writeString(self.topic.encode('utf-8') if sys.version_info[0] == 2 else self.topic)
            oprot.writeFieldEnd()
        if self.mutationTable is not None:
            oprot.writeFieldBegin('mutationTable', TType.STRING, 3)
            oprot.writeString(self.mutationTable.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTable)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LogicalNode(object):
    """
    Attributes:
     - stagingQuery
     - join
     - groupBy
     - model
     - tabularData

    """


    def __init__(self, stagingQuery=None, join=None, groupBy=None, model=None, tabularData=None,):
        self.stagingQuery = stagingQuery
        self.join = join
        self.groupBy = groupBy
        self.model = model
        self.tabularData = tabularData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stagingQuery = ai.chronon.api.ttypes.StagingQuery()
                    self.stagingQuery.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.join = ai.chronon.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.groupBy = ai.chronon.api.ttypes.GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.model = ai.chronon.api.ttypes.Model()
                    self.model.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.tabularData = TabularData()
                    self.tabularData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LogicalNode')
        if self.stagingQuery is not None:
            oprot.writeFieldBegin('stagingQuery', TType.STRUCT, 1)
            self.stagingQuery.write(oprot)
            oprot.writeFieldEnd()
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 3)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.STRUCT, 4)
            self.model.write(oprot)
            oprot.writeFieldEnd()
        if self.tabularData is not None:
            oprot.writeFieldBegin('tabularData', TType.STRUCT, 5)
            self.tabularData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeKey(object):
    """
    Attributes:
     - name
     - logicalType
     - physicalType

    """


    def __init__(self, name=None, logicalType=None, physicalType=None,):
        self.name = name
        self.logicalType = logicalType
        self.physicalType = physicalType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.logicalType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.physicalType = PhysicalNodeType()
                    self.physicalType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeKey')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.logicalType is not None:
            oprot.writeFieldBegin('logicalType', TType.I32, 2)
            oprot.writeI32(self.logicalType)
            oprot.writeFieldEnd()
        if self.physicalType is not None:
            oprot.writeFieldBegin('physicalType', TType.STRUCT, 3)
            self.physicalType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeInfo(object):
    """
    Attributes:
     - semanticHash: represents the computation that a node does
    direct changes to conf that change output will affect semantic hash
    changing spark params etc shouldn't affect this

     - confHash: simple hash of the entire conf (that is TSimpleJsonProtocol serialized),
    computed by cli and used to check if new conf_json need to be pushed from user's machine

     - branch: when new/updated conf's are pushed the branch is also set from the cli
    upon merging the branch will be unset

     - author: will be set to the author of the last semantic change to node
    (non-semantic changes like code-mods or spark params don't affect this)

     - conf: contents of the conf itself


    """


    def __init__(self, semanticHash=None, confHash=None, branch=None, author=None, conf=None,):
        self.semanticHash = semanticHash
        self.confHash = confHash
        self.branch = branch
        self.author = author
        self.conf = conf

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 11:
                if ftype == TType.STRING:
                    self.semanticHash = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.confHash = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.branch = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRING:
                    self.author = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.STRUCT:
                    self.conf = LogicalNode()
                    self.conf.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeInfo')
        if self.semanticHash is not None:
            oprot.writeFieldBegin('semanticHash', TType.STRING, 11)
            oprot.writeString(self.semanticHash.encode('utf-8') if sys.version_info[0] == 2 else self.semanticHash)
            oprot.writeFieldEnd()
        if self.confHash is not None:
            oprot.writeFieldBegin('confHash', TType.STRING, 12)
            oprot.writeString(self.confHash.encode('utf-8') if sys.version_info[0] == 2 else self.confHash)
            oprot.writeFieldEnd()
        if self.branch is not None:
            oprot.writeFieldBegin('branch', TType.STRING, 20)
            oprot.writeString(self.branch.encode('utf-8') if sys.version_info[0] == 2 else self.branch)
            oprot.writeFieldEnd()
        if self.author is not None:
            oprot.writeFieldBegin('author', TType.STRING, 21)
            oprot.writeString(self.author.encode('utf-8') if sys.version_info[0] == 2 else self.author)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.STRUCT, 30)
            self.conf.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeConnections(object):
    """
    Attributes:
     - parents
     - children

    """


    def __init__(self, parents=None, children=None,):
        self.parents = parents
        self.children = children

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.parents = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = NodeKey()
                        _elem5.read(iprot)
                        self.parents.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.children = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = NodeKey()
                        _elem11.read(iprot)
                        self.children.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeConnections')
        if self.parents is not None:
            oprot.writeFieldBegin('parents', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.parents))
            for iter12 in self.parents:
                iter12.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.children is not None:
            oprot.writeFieldBegin('children', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.children))
            for iter13 in self.children:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeGraph(object):
    """
    Attributes:
     - connections
     - infoMap

    """


    def __init__(self, connections=None, infoMap=None,):
        self.connections = connections
        self.infoMap = infoMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.connections = {}
                    (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
                    for _i18 in range(_size14):
                        _key19 = NodeKey()
                        _key19.read(iprot)
                        _val20 = NodeConnections()
                        _val20.read(iprot)
                        self.connections[_key19] = _val20
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.infoMap = {}
                    (_ktype22, _vtype23, _size21) = iprot.readMapBegin()
                    for _i25 in range(_size21):
                        _key26 = NodeKey()
                        _key26.read(iprot)
                        _val27 = NodeInfo()
                        _val27.read(iprot)
                        self.infoMap[_key26] = _val27
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeGraph')
        if self.connections is not None:
            oprot.writeFieldBegin('connections', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.connections))
            for kiter28, viter29 in self.connections.items():
                kiter28.write(oprot)
                viter29.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.infoMap is not None:
            oprot.writeFieldBegin('infoMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.infoMap))
            for kiter30, viter31 in self.infoMap.items():
                kiter30.write(oprot)
                viter31.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PhysicalNodeType(object):
    """
    Attributes:
     - groupByNodeType
     - joinNodeType
     - stagingNodeType
     - modelNodeType
     - tableNodeType

    """


    def __init__(self, groupByNodeType=None, joinNodeType=None, stagingNodeType=None, modelNodeType=None, tableNodeType=None,):
        self.groupByNodeType = groupByNodeType
        self.joinNodeType = joinNodeType
        self.stagingNodeType = stagingNodeType
        self.modelNodeType = modelNodeType
        self.tableNodeType = tableNodeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.groupByNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.joinNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.stagingNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.modelNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.tableNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PhysicalNodeType')
        if self.groupByNodeType is not None:
            oprot.writeFieldBegin('groupByNodeType', TType.I32, 1)
            oprot.writeI32(self.groupByNodeType)
            oprot.writeFieldEnd()
        if self.joinNodeType is not None:
            oprot.writeFieldBegin('joinNodeType', TType.I32, 2)
            oprot.writeI32(self.joinNodeType)
            oprot.writeFieldEnd()
        if self.stagingNodeType is not None:
            oprot.writeFieldBegin('stagingNodeType', TType.I32, 3)
            oprot.writeI32(self.stagingNodeType)
            oprot.writeFieldEnd()
        if self.modelNodeType is not None:
            oprot.writeFieldBegin('modelNodeType', TType.I32, 4)
            oprot.writeI32(self.modelNodeType)
            oprot.writeFieldEnd()
        if self.tableNodeType is not None:
            oprot.writeFieldBegin('tableNodeType', TType.I32, 5)
            oprot.writeI32(self.tableNodeType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PhysicalNode(object):
    """
    Attributes:
     - name
     - nodeType
     - logicalNode
     - confHash
     - tableDependencies
     - outputColumns
     - outputTable

    """


    def __init__(self, name=None, nodeType=None, logicalNode=None, confHash=None, tableDependencies=None, outputColumns=None, outputTable=None,):
        self.name = name
        self.nodeType = nodeType
        self.logicalNode = logicalNode
        self.confHash = confHash
        self.tableDependencies = tableDependencies
        self.outputColumns = outputColumns
        self.outputTable = outputTable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.nodeType = PhysicalNodeType()
                    self.nodeType.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.logicalNode = LogicalNode()
                    self.logicalNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.confHash = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.LIST:
                    self.tableDependencies = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = ai.chronon.api.common.ttypes.TableDependency()
                        _elem37.read(iprot)
                        self.tableDependencies.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.LIST:
                    self.outputColumns = []
                    (_etype41, _size38) = iprot.readListBegin()
                    for _i42 in range(_size38):
                        _elem43 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.outputColumns.append(_elem43)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 102:
                if ftype == TType.STRING:
                    self.outputTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PhysicalNode')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.nodeType is not None:
            oprot.writeFieldBegin('nodeType', TType.STRUCT, 2)
            self.nodeType.write(oprot)
            oprot.writeFieldEnd()
        if self.logicalNode is not None:
            oprot.writeFieldBegin('logicalNode', TType.STRUCT, 3)
            self.logicalNode.write(oprot)
            oprot.writeFieldEnd()
        if self.confHash is not None:
            oprot.writeFieldBegin('confHash', TType.STRING, 4)
            oprot.writeString(self.confHash.encode('utf-8') if sys.version_info[0] == 2 else self.confHash)
            oprot.writeFieldEnd()
        if self.tableDependencies is not None:
            oprot.writeFieldBegin('tableDependencies', TType.LIST, 100)
            oprot.writeListBegin(TType.STRUCT, len(self.tableDependencies))
            for iter44 in self.tableDependencies:
                iter44.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.outputColumns is not None:
            oprot.writeFieldBegin('outputColumns', TType.LIST, 101)
            oprot.writeListBegin(TType.STRING, len(self.outputColumns))
            for iter45 in self.outputColumns:
                oprot.writeString(iter45.encode('utf-8') if sys.version_info[0] == 2 else iter45)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.outputTable is not None:
            oprot.writeFieldBegin('outputTable', TType.STRING, 102)
            oprot.writeString(self.outputTable.encode('utf-8') if sys.version_info[0] == 2 else self.outputTable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PhysicalGraph(object):
    """
    Attributes:
     - node
     - dependencies
     - range

    """


    def __init__(self, node=None, dependencies=None, range=None,):
        self.node = node
        self.dependencies = dependencies
        self.range = range

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.node = PhysicalNode()
                    self.node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dependencies = []
                    (_etype49, _size46) = iprot.readListBegin()
                    for _i50 in range(_size46):
                        _elem51 = PhysicalGraph()
                        _elem51.read(iprot)
                        self.dependencies.append(_elem51)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.range = ai.chronon.api.common.ttypes.DateRange()
                    self.range.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PhysicalGraph')
        if self.node is not None:
            oprot.writeFieldBegin('node', TType.STRUCT, 1)
            self.node.write(oprot)
            oprot.writeFieldEnd()
        if self.dependencies is not None:
            oprot.writeFieldBegin('dependencies', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dependencies))
            for iter52 in self.dependencies:
                iter52.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.STRUCT, 3)
            self.range.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PhysicalNodeKey(object):
    """
    Multiple logical nodes could share the same physical node
    For that reason we don't have a 1-1 mapping between logical and physical nodes
    TODO -- kill this (typescript dependency)


    Attributes:
     - name
     - nodeType

    """


    def __init__(self, name=None, nodeType=None,):
        self.name = name
        self.nodeType = nodeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.nodeType = PhysicalNodeType()
                    self.nodeType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PhysicalNodeKey')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.nodeType is not None:
            oprot.writeFieldBegin('nodeType', TType.STRUCT, 2)
            self.nodeType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SourceWithFilterNode(object):
    """
    Attributes:
     - metaData
     - source
     - excludeKeys

    """


    def __init__(self, metaData=None, source=None, excludeKeys=None,):
        self.metaData = metaData
        self.source = source
        self.excludeKeys = excludeKeys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = ai.chronon.api.ttypes.MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.source = ai.chronon.api.ttypes.Source()
                    self.source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.excludeKeys = {}
                    (_ktype54, _vtype55, _size53) = iprot.readMapBegin()
                    for _i57 in range(_size53):
                        _key58 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val59 = []
                        (_etype63, _size60) = iprot.readListBegin()
                        for _i64 in range(_size60):
                            _elem65 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val59.append(_elem65)
                        iprot.readListEnd()
                        self.excludeKeys[_key58] = _val59
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SourceWithFilterNode')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRUCT, 2)
            self.source.write(oprot)
            oprot.writeFieldEnd()
        if self.excludeKeys is not None:
            oprot.writeFieldBegin('excludeKeys', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.excludeKeys))
            for kiter66, viter67 in self.excludeKeys.items():
                oprot.writeString(kiter66.encode('utf-8') if sys.version_info[0] == 2 else kiter66)
                oprot.writeListBegin(TType.STRING, len(viter67))
                for iter68 in viter67:
                    oprot.writeString(iter68.encode('utf-8') if sys.version_info[0] == 2 else iter68)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinBootstrapNode(object):
    """
    Attributes:
     - metaData
     - join

    """


    def __init__(self, metaData=None, join=None,):
        self.metaData = metaData
        self.join = join

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = ai.chronon.api.ttypes.MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.join = ai.chronon.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinBootstrapNode')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinMergeNode(object):
    """
    Attributes:
     - metaData
     - join

    """


    def __init__(self, metaData=None, join=None,):
        self.metaData = metaData
        self.join = join

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = ai.chronon.api.ttypes.MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.join = ai.chronon.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinMergeNode')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinDerivationNode(object):
    """
    Attributes:
     - metaData
     - join

    """


    def __init__(self, metaData=None, join=None,):
        self.metaData = metaData
        self.join = join

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = ai.chronon.api.ttypes.MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.join = ai.chronon.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinDerivationNode')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinPartNode(object):
    """
    Attributes:
     - metaData
     - leftSourceTable
     - leftDataModel
     - joinPart
     - skewKeys

    """


    def __init__(self, metaData=None, leftSourceTable=None, leftDataModel=None, joinPart=None, skewKeys=None,):
        self.metaData = metaData
        self.leftSourceTable = leftSourceTable
        self.leftDataModel = leftDataModel
        self.joinPart = joinPart
        self.skewKeys = skewKeys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = ai.chronon.api.ttypes.MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.leftSourceTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.leftDataModel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.joinPart = ai.chronon.api.ttypes.JoinPart()
                    self.joinPart.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.skewKeys = {}
                    (_ktype70, _vtype71, _size69) = iprot.readMapBegin()
                    for _i73 in range(_size69):
                        _key74 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val75 = []
                        (_etype79, _size76) = iprot.readListBegin()
                        for _i80 in range(_size76):
                            _elem81 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val75.append(_elem81)
                        iprot.readListEnd()
                        self.skewKeys[_key74] = _val75
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinPartNode')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.leftSourceTable is not None:
            oprot.writeFieldBegin('leftSourceTable', TType.STRING, 2)
            oprot.writeString(self.leftSourceTable.encode('utf-8') if sys.version_info[0] == 2 else self.leftSourceTable)
            oprot.writeFieldEnd()
        if self.leftDataModel is not None:
            oprot.writeFieldBegin('leftDataModel', TType.I32, 3)
            oprot.writeI32(self.leftDataModel)
            oprot.writeFieldEnd()
        if self.joinPart is not None:
            oprot.writeFieldBegin('joinPart', TType.STRUCT, 4)
            self.joinPart.write(oprot)
            oprot.writeFieldEnd()
        if self.skewKeys is not None:
            oprot.writeFieldBegin('skewKeys', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.skewKeys))
            for kiter82, viter83 in self.skewKeys.items():
                oprot.writeString(kiter82.encode('utf-8') if sys.version_info[0] == 2 else kiter82)
                oprot.writeListBegin(TType.STRING, len(viter83))
                for iter84 in viter83:
                    oprot.writeString(iter84.encode('utf-8') if sys.version_info[0] == 2 else iter84)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LabelPartNode(object):
    """
    Attributes:
     - metaData
     - join

    """


    def __init__(self, metaData=None, join=None,):
        self.metaData = metaData
        self.join = join

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = ai.chronon.api.ttypes.MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.join = ai.chronon.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LabelPartNode')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeUnion(object):
    """
    Attributes:
     - sourceWithFilter
     - joinBootstrap
     - joinPart
     - joinMerge
     - joinDerivation
     - labelPart

    """


    def __init__(self, sourceWithFilter=None, joinBootstrap=None, joinPart=None, joinMerge=None, joinDerivation=None, labelPart=None,):
        self.sourceWithFilter = sourceWithFilter
        self.joinBootstrap = joinBootstrap
        self.joinPart = joinPart
        self.joinMerge = joinMerge
        self.joinDerivation = joinDerivation
        self.labelPart = labelPart

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceWithFilter = SourceWithFilterNode()
                    self.sourceWithFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.joinBootstrap = JoinBootstrapNode()
                    self.joinBootstrap.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.joinPart = JoinPartNode()
                    self.joinPart.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.joinMerge = JoinMergeNode()
                    self.joinMerge.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.joinDerivation = JoinDerivationNode()
                    self.joinDerivation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.labelPart = LabelPartNode()
                    self.labelPart.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeUnion')
        if self.sourceWithFilter is not None:
            oprot.writeFieldBegin('sourceWithFilter', TType.STRUCT, 1)
            self.sourceWithFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.joinBootstrap is not None:
            oprot.writeFieldBegin('joinBootstrap', TType.STRUCT, 2)
            self.joinBootstrap.write(oprot)
            oprot.writeFieldEnd()
        if self.joinPart is not None:
            oprot.writeFieldBegin('joinPart', TType.STRUCT, 3)
            self.joinPart.write(oprot)
            oprot.writeFieldEnd()
        if self.joinMerge is not None:
            oprot.writeFieldBegin('joinMerge', TType.STRUCT, 4)
            self.joinMerge.write(oprot)
            oprot.writeFieldEnd()
        if self.joinDerivation is not None:
            oprot.writeFieldBegin('joinDerivation', TType.STRUCT, 5)
            self.joinDerivation.write(oprot)
            oprot.writeFieldEnd()
        if self.labelPart is not None:
            oprot.writeFieldBegin('labelPart', TType.STRUCT, 6)
            self.labelPart.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Conf(object):
    """
    Attributes:
     - name
     - hash
     - contents

    """


    def __init__(self, name=None, hash=None, contents=None,):
        self.name = name
        self.hash = hash
        self.contents = contents

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hash = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.contents = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Conf')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.hash is not None:
            oprot.writeFieldBegin('hash', TType.STRING, 2)
            oprot.writeString(self.hash.encode('utf-8') if sys.version_info[0] == 2 else self.hash)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin('contents', TType.STRING, 3)
            oprot.writeString(self.contents.encode('utf-8') if sys.version_info[0] == 2 else self.contents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DiffRequest(object):
    """
    Attributes:
     - namesToHashes

    """


    def __init__(self, namesToHashes=None,):
        self.namesToHashes = namesToHashes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.namesToHashes = {}
                    (_ktype86, _vtype87, _size85) = iprot.readMapBegin()
                    for _i89 in range(_size85):
                        _key90 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val91 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.namesToHashes[_key90] = _val91
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DiffRequest')
        if self.namesToHashes is not None:
            oprot.writeFieldBegin('namesToHashes', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.namesToHashes))
            for kiter92, viter93 in self.namesToHashes.items():
                oprot.writeString(kiter92.encode('utf-8') if sys.version_info[0] == 2 else kiter92)
                oprot.writeString(viter93.encode('utf-8') if sys.version_info[0] == 2 else viter93)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DiffResponse(object):
    """
    Attributes:
     - diff

    """


    def __init__(self, diff=None,):
        self.diff = diff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.diff = []
                    (_etype97, _size94) = iprot.readListBegin()
                    for _i98 in range(_size94):
                        _elem99 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.diff.append(_elem99)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DiffResponse')
        if self.diff is not None:
            oprot.writeFieldBegin('diff', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.diff))
            for iter100 in self.diff:
                oprot.writeString(iter100.encode('utf-8') if sys.version_info[0] == 2 else iter100)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UploadRequest(object):
    """
    Attributes:
     - diffConfs
     - branch

    """


    def __init__(self, diffConfs=None, branch=None,):
        self.diffConfs = diffConfs
        self.branch = branch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.diffConfs = []
                    (_etype104, _size101) = iprot.readListBegin()
                    for _i105 in range(_size101):
                        _elem106 = Conf()
                        _elem106.read(iprot)
                        self.diffConfs.append(_elem106)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.branch = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UploadRequest')
        if self.diffConfs is not None:
            oprot.writeFieldBegin('diffConfs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.diffConfs))
            for iter107 in self.diffConfs:
                iter107.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.branch is not None:
            oprot.writeFieldBegin('branch', TType.STRING, 2)
            oprot.writeString(self.branch.encode('utf-8') if sys.version_info[0] == 2 else self.branch)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UploadResponse(object):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UploadResponse')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TabularData)
TabularData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'topic', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mutationTable', 'UTF8', None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
)
all_structs.append(LogicalNode)
LogicalNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stagingQuery', [ai.chronon.api.ttypes.StagingQuery, None], None, ),  # 1
    (2, TType.STRUCT, 'join', [ai.chronon.api.ttypes.Join, None], None, ),  # 2
    (3, TType.STRUCT, 'groupBy', [ai.chronon.api.ttypes.GroupBy, None], None, ),  # 3
    (4, TType.STRUCT, 'model', [ai.chronon.api.ttypes.Model, None], None, ),  # 4
    (5, TType.STRUCT, 'tabularData', [TabularData, None], None, ),  # 5
)
all_structs.append(NodeKey)
NodeKey.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'logicalType', None, None, ),  # 2
    (3, TType.STRUCT, 'physicalType', [PhysicalNodeType, None], None, ),  # 3
)
all_structs.append(NodeInfo)
NodeInfo.thrift_spec = (
    None,  # 0
    None,  # 1
    None,  # 2
    None,  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    (11, TType.STRING, 'semanticHash', 'UTF8', None, ),  # 11
    (12, TType.STRING, 'confHash', 'UTF8', None, ),  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.STRING, 'branch', 'UTF8', None, ),  # 20
    (21, TType.STRING, 'author', 'UTF8', None, ),  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    (30, TType.STRUCT, 'conf', [LogicalNode, None], None, ),  # 30
)
all_structs.append(NodeConnections)
NodeConnections.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'parents', (TType.STRUCT, [NodeKey, None], False), None, ),  # 1
    (2, TType.LIST, 'children', (TType.STRUCT, [NodeKey, None], False), None, ),  # 2
)
all_structs.append(NodeGraph)
NodeGraph.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'connections', (TType.STRUCT, [NodeKey, None], TType.STRUCT, [NodeConnections, None], False), None, ),  # 1
    (2, TType.MAP, 'infoMap', (TType.STRUCT, [NodeKey, None], TType.STRUCT, [NodeInfo, None], False), None, ),  # 2
)
all_structs.append(PhysicalNodeType)
PhysicalNodeType.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'groupByNodeType', None, None, ),  # 1
    (2, TType.I32, 'joinNodeType', None, None, ),  # 2
    (3, TType.I32, 'stagingNodeType', None, None, ),  # 3
    (4, TType.I32, 'modelNodeType', None, None, ),  # 4
    (5, TType.I32, 'tableNodeType', None, None, ),  # 5
)
all_structs.append(PhysicalNode)
PhysicalNode.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'nodeType', [PhysicalNodeType, None], None, ),  # 2
    (3, TType.STRUCT, 'logicalNode', [LogicalNode, None], None, ),  # 3
    (4, TType.STRING, 'confHash', 'UTF8', None, ),  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    (100, TType.LIST, 'tableDependencies', (TType.STRUCT, [ai.chronon.api.common.ttypes.TableDependency, None], False), None, ),  # 100
    (101, TType.LIST, 'outputColumns', (TType.STRING, 'UTF8', False), None, ),  # 101
    (102, TType.STRING, 'outputTable', 'UTF8', None, ),  # 102
)
all_structs.append(PhysicalGraph)
PhysicalGraph.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'node', [PhysicalNode, None], None, ),  # 1
    (2, TType.LIST, 'dependencies', (TType.STRUCT, [PhysicalGraph, None], False), None, ),  # 2
    (3, TType.STRUCT, 'range', [ai.chronon.api.common.ttypes.DateRange, None], None, ),  # 3
)
all_structs.append(PhysicalNodeKey)
PhysicalNodeKey.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'nodeType', [PhysicalNodeType, None], None, ),  # 2
)
all_structs.append(SourceWithFilterNode)
SourceWithFilterNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [ai.chronon.api.ttypes.MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'source', [ai.chronon.api.ttypes.Source, None], None, ),  # 2
    (3, TType.MAP, 'excludeKeys', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
)
all_structs.append(JoinBootstrapNode)
JoinBootstrapNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [ai.chronon.api.ttypes.MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'join', [ai.chronon.api.ttypes.Join, None], None, ),  # 2
)
all_structs.append(JoinMergeNode)
JoinMergeNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [ai.chronon.api.ttypes.MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'join', [ai.chronon.api.ttypes.Join, None], None, ),  # 2
)
all_structs.append(JoinDerivationNode)
JoinDerivationNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [ai.chronon.api.ttypes.MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'join', [ai.chronon.api.ttypes.Join, None], None, ),  # 2
)
all_structs.append(JoinPartNode)
JoinPartNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [ai.chronon.api.ttypes.MetaData, None], None, ),  # 1
    (2, TType.STRING, 'leftSourceTable', 'UTF8', None, ),  # 2
    (3, TType.I32, 'leftDataModel', None, None, ),  # 3
    (4, TType.STRUCT, 'joinPart', [ai.chronon.api.ttypes.JoinPart, None], None, ),  # 4
    (5, TType.MAP, 'skewKeys', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 5
)
all_structs.append(LabelPartNode)
LabelPartNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [ai.chronon.api.ttypes.MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'join', [ai.chronon.api.ttypes.Join, None], None, ),  # 2
)
all_structs.append(NodeUnion)
NodeUnion.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceWithFilter', [SourceWithFilterNode, None], None, ),  # 1
    (2, TType.STRUCT, 'joinBootstrap', [JoinBootstrapNode, None], None, ),  # 2
    (3, TType.STRUCT, 'joinPart', [JoinPartNode, None], None, ),  # 3
    (4, TType.STRUCT, 'joinMerge', [JoinMergeNode, None], None, ),  # 4
    (5, TType.STRUCT, 'joinDerivation', [JoinDerivationNode, None], None, ),  # 5
    (6, TType.STRUCT, 'labelPart', [LabelPartNode, None], None, ),  # 6
)
all_structs.append(Conf)
Conf.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'hash', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'contents', 'UTF8', None, ),  # 3
)
all_structs.append(DiffRequest)
DiffRequest.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'namesToHashes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(DiffResponse)
DiffResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'diff', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(UploadRequest)
UploadRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'diffConfs', (TType.STRUCT, [Conf, None], False), None, ),  # 1
    (2, TType.STRING, 'branch', 'UTF8', None, ),  # 2
)
all_structs.append(UploadResponse)
UploadResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
