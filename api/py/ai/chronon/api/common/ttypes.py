#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class TimeUnit(object):
    HOURS = 0
    DAYS = 1
    MINUTES = 2

    _VALUES_TO_NAMES = {
        0: "HOURS",
        1: "DAYS",
        2: "MINUTES",
    }

    _NAMES_TO_VALUES = {
        "HOURS": 0,
        "DAYS": 1,
        "MINUTES": 2,
    }


class ConfigType(object):
    STAGING_QUERY = 1
    GROUP_BY = 2
    JOIN = 3
    MODEL = 4

    _VALUES_TO_NAMES = {
        1: "STAGING_QUERY",
        2: "GROUP_BY",
        3: "JOIN",
        4: "MODEL",
    }

    _NAMES_TO_VALUES = {
        "STAGING_QUERY": 1,
        "GROUP_BY": 2,
        "JOIN": 3,
        "MODEL": 4,
    }


class KvScanStrategy(object):
    ALL = 0
    LATEST = 1

    _VALUES_TO_NAMES = {
        0: "ALL",
        1: "LATEST",
    }

    _NAMES_TO_VALUES = {
        "ALL": 0,
        "LATEST": 1,
    }


class Window(object):
    """
    Attributes:
     - length
     - timeUnit

    """


    def __init__(self, length=None, timeUnit=None,):
        self.length = length
        self.timeUnit = timeUnit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeUnit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Window')
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 1)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        if self.timeUnit is not None:
            oprot.writeFieldBegin('timeUnit', TType.I32, 2)
            oprot.writeI32(self.timeUnit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DateRange(object):
    """
    Attributes:
     - startDate
     - endDate

    """


    def __init__(self, startDate=None, endDate=None,):
        self.startDate = startDate
        self.endDate = endDate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.startDate = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.endDate = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DateRange')
        if self.startDate is not None:
            oprot.writeFieldBegin('startDate', TType.STRING, 1)
            oprot.writeString(self.startDate.encode('utf-8') if sys.version_info[0] == 2 else self.startDate)
            oprot.writeFieldEnd()
        if self.endDate is not None:
            oprot.writeFieldBegin('endDate', TType.STRING, 2)
            oprot.writeString(self.endDate.encode('utf-8') if sys.version_info[0] == 2 else self.endDate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EnvironmentVariables(object):
    """
    env vars for different modes of execution - with "common" applying to all modes
    the submitter will set these env vars prior to launching the job

    these env vars are layered in order of priority
      1. company file defaults specified in teams.py - in the "common" team
      2. team wide defaults that apply to all objects in the team folder
      3. object specific defaults - applies to only the object that are declares them

    All the maps from the above three places are merged to create final env var


    Attributes:
     - common
     - modeEnvironments

    """


    def __init__(self, common=None, modeEnvironments=None,):
        self.common = common
        self.modeEnvironments = modeEnvironments

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.common = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.common[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.modeEnvironments = {}
                    (_ktype8, _vtype9, _size7) = iprot.readMapBegin()
                    for _i11 in range(_size7):
                        _key12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val13 = {}
                        (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
                        for _i18 in range(_size14):
                            _key19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val20 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val13[_key19] = _val20
                        iprot.readMapEnd()
                        self.modeEnvironments[_key12] = _val13
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EnvironmentVariables')
        if self.common is not None:
            oprot.writeFieldBegin('common', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.common))
            for kiter21, viter22 in self.common.items():
                oprot.writeString(kiter21.encode('utf-8') if sys.version_info[0] == 2 else kiter21)
                oprot.writeString(viter22.encode('utf-8') if sys.version_info[0] == 2 else viter22)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.modeEnvironments is not None:
            oprot.writeFieldBegin('modeEnvironments', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.modeEnvironments))
            for kiter23, viter24 in self.modeEnvironments.items():
                oprot.writeString(kiter23.encode('utf-8') if sys.version_info[0] == 2 else kiter23)
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter24))
                for kiter25, viter26 in viter24.items():
                    oprot.writeString(kiter25.encode('utf-8') if sys.version_info[0] == 2 else kiter25)
                    oprot.writeString(viter26.encode('utf-8') if sys.version_info[0] == 2 else viter26)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfigProperties(object):
    """
    job config for different modes of execution - with "common" applying to all modes
    usually these are spark or flink conf params like "spark.executor.memory" etc

    these confs are layered in order of priority
      1. company file defaults specified in teams.py - in the "common" team
      2. team wide defaults that apply to all objects in the team folder
      3. object specific defaults - applies to only the object that are declares them

    All the maps from the above three places are merged to create final conf map


    Attributes:
     - common
     - modeConfigs

    """


    def __init__(self, common=None, modeConfigs=None,):
        self.common = common
        self.modeConfigs = modeConfigs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.common = {}
                    (_ktype28, _vtype29, _size27) = iprot.readMapBegin()
                    for _i31 in range(_size27):
                        _key32 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val33 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.common[_key32] = _val33
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.modeConfigs = {}
                    (_ktype35, _vtype36, _size34) = iprot.readMapBegin()
                    for _i38 in range(_size34):
                        _key39 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val40 = {}
                        (_ktype42, _vtype43, _size41) = iprot.readMapBegin()
                        for _i45 in range(_size41):
                            _key46 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val47 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val40[_key46] = _val47
                        iprot.readMapEnd()
                        self.modeConfigs[_key39] = _val40
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfigProperties')
        if self.common is not None:
            oprot.writeFieldBegin('common', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.common))
            for kiter48, viter49 in self.common.items():
                oprot.writeString(kiter48.encode('utf-8') if sys.version_info[0] == 2 else kiter48)
                oprot.writeString(viter49.encode('utf-8') if sys.version_info[0] == 2 else viter49)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.modeConfigs is not None:
            oprot.writeFieldBegin('modeConfigs', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.modeConfigs))
            for kiter50, viter51 in self.modeConfigs.items():
                oprot.writeString(kiter50.encode('utf-8') if sys.version_info[0] == 2 else kiter50)
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter51))
                for kiter52, viter53 in viter51.items():
                    oprot.writeString(kiter52.encode('utf-8') if sys.version_info[0] == 2 else kiter52)
                    oprot.writeString(viter53.encode('utf-8') if sys.version_info[0] == 2 else viter53)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableInfo(object):
    """
    Attributes:
     - table
     - partitionColumn
     - partitionFormat
     - partitionInterval
     - isCumulative: If isCumulative is true, then for a given output partition any single partition from input on or after the output
    is sufficient. What this means is that latest available partition prior to end cut off will be used.


    """


    def __init__(self, table=None, partitionColumn=None, partitionFormat=None, partitionInterval=None, isCumulative=None,):
        self.table = table
        self.partitionColumn = partitionColumn
        self.partitionFormat = partitionFormat
        self.partitionInterval = partitionInterval
        self.isCumulative = isCumulative

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.STRING:
                    self.partitionColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.STRING:
                    self.partitionFormat = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 102:
                if ftype == TType.STRUCT:
                    self.partitionInterval = Window()
                    self.partitionInterval.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 200:
                if ftype == TType.BOOL:
                    self.isCumulative = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableInfo')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 1)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.partitionColumn is not None:
            oprot.writeFieldBegin('partitionColumn', TType.STRING, 100)
            oprot.writeString(self.partitionColumn.encode('utf-8') if sys.version_info[0] == 2 else self.partitionColumn)
            oprot.writeFieldEnd()
        if self.partitionFormat is not None:
            oprot.writeFieldBegin('partitionFormat', TType.STRING, 101)
            oprot.writeString(self.partitionFormat.encode('utf-8') if sys.version_info[0] == 2 else self.partitionFormat)
            oprot.writeFieldEnd()
        if self.partitionInterval is not None:
            oprot.writeFieldBegin('partitionInterval', TType.STRUCT, 102)
            self.partitionInterval.write(oprot)
            oprot.writeFieldEnd()
        if self.isCumulative is not None:
            oprot.writeFieldBegin('isCumulative', TType.BOOL, 200)
            oprot.writeBool(self.isCumulative)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableDependency(object):
    """
    Attributes:
     - tableInfo
     - startOffset
     - endOffset
     - startCutOff
     - endCutOff
     - forceCompute: JoinParts could use data from batch backfill-s or upload tables when available
    When not available they shouldn't force computation of the backfills and upload tables.


    """


    def __init__(self, tableInfo=None, startOffset=None, endOffset=None, startCutOff=None, endCutOff=None, forceCompute=None,):
        self.tableInfo = tableInfo
        self.startOffset = startOffset
        self.endOffset = endOffset
        self.startCutOff = startCutOff
        self.endCutOff = endCutOff
        self.forceCompute = forceCompute

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tableInfo = TableInfo()
                    self.tableInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.startOffset = Window()
                    self.startOffset.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.endOffset = Window()
                    self.endOffset.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.startCutOff = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.endCutOff = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 201:
                if ftype == TType.BOOL:
                    self.forceCompute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableDependency')
        if self.tableInfo is not None:
            oprot.writeFieldBegin('tableInfo', TType.STRUCT, 1)
            self.tableInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.startOffset is not None:
            oprot.writeFieldBegin('startOffset', TType.STRUCT, 2)
            self.startOffset.write(oprot)
            oprot.writeFieldEnd()
        if self.endOffset is not None:
            oprot.writeFieldBegin('endOffset', TType.STRUCT, 3)
            self.endOffset.write(oprot)
            oprot.writeFieldEnd()
        if self.startCutOff is not None:
            oprot.writeFieldBegin('startCutOff', TType.STRING, 4)
            oprot.writeString(self.startCutOff.encode('utf-8') if sys.version_info[0] == 2 else self.startCutOff)
            oprot.writeFieldEnd()
        if self.endCutOff is not None:
            oprot.writeFieldBegin('endCutOff', TType.STRING, 5)
            oprot.writeString(self.endCutOff.encode('utf-8') if sys.version_info[0] == 2 else self.endCutOff)
            oprot.writeFieldEnd()
        if self.forceCompute is not None:
            oprot.writeFieldBegin('forceCompute', TType.BOOL, 201)
            oprot.writeBool(self.forceCompute)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KvDependency(object):
    """
    Attributes:
     - cluster
     - table
     - keyBase64
     - startMillis
     - endMillis
     - scanStrategy

    """


    def __init__(self, cluster=None, table=None, keyBase64=None, startMillis=None, endMillis=None, scanStrategy=None,):
        self.cluster = cluster
        self.table = table
        self.keyBase64 = keyBase64
        self.startMillis = startMillis
        self.endMillis = endMillis
        self.scanStrategy = scanStrategy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keyBase64 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.startMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.endMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I32:
                    self.scanStrategy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KvDependency')
        if self.cluster is not None:
            oprot.writeFieldBegin('cluster', TType.STRING, 1)
            oprot.writeString(self.cluster.encode('utf-8') if sys.version_info[0] == 2 else self.cluster)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 2)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.keyBase64 is not None:
            oprot.writeFieldBegin('keyBase64', TType.STRING, 3)
            oprot.writeString(self.keyBase64.encode('utf-8') if sys.version_info[0] == 2 else self.keyBase64)
            oprot.writeFieldEnd()
        if self.startMillis is not None:
            oprot.writeFieldBegin('startMillis', TType.I64, 10)
            oprot.writeI64(self.startMillis)
            oprot.writeFieldEnd()
        if self.endMillis is not None:
            oprot.writeFieldBegin('endMillis', TType.I64, 11)
            oprot.writeI64(self.endMillis)
            oprot.writeFieldEnd()
        if self.scanStrategy is not None:
            oprot.writeFieldBegin('scanStrategy', TType.I32, 20)
            oprot.writeI32(self.scanStrategy)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecutionInfo(object):
    """
    Attributes:
     - env
     - conf
     - dependencyPollIntervalMillis
     - healthCheckIntervalMillis
     - scheduleCron
     - stepDays
     - historicalBackfill
     - tableDependencies
     - outputTableInfo
     - kvDependency
     - kvPollIntervalMillis

    """


    def __init__(self, env=None, conf=None, dependencyPollIntervalMillis=None, healthCheckIntervalMillis=None, scheduleCron=None, stepDays=None, historicalBackfill=None, tableDependencies=None, outputTableInfo=None, kvDependency=None, kvPollIntervalMillis=None,):
        self.env = env
        self.conf = conf
        self.dependencyPollIntervalMillis = dependencyPollIntervalMillis
        self.healthCheckIntervalMillis = healthCheckIntervalMillis
        self.scheduleCron = scheduleCron
        self.stepDays = stepDays
        self.historicalBackfill = historicalBackfill
        self.tableDependencies = tableDependencies
        self.outputTableInfo = outputTableInfo
        self.kvDependency = kvDependency
        self.kvPollIntervalMillis = kvPollIntervalMillis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.env = EnvironmentVariables()
                    self.env.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.conf = ConfigProperties()
                    self.conf.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.dependencyPollIntervalMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.healthCheckIntervalMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.scheduleCron = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.stepDays = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.historicalBackfill = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.tableDependencies = []
                    (_etype57, _size54) = iprot.readListBegin()
                    for _i58 in range(_size54):
                        _elem59 = TableDependency()
                        _elem59.read(iprot)
                        self.tableDependencies.append(_elem59)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.outputTableInfo = TableInfo()
                    self.outputTableInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 200:
                if ftype == TType.LIST:
                    self.kvDependency = []
                    (_etype63, _size60) = iprot.readListBegin()
                    for _i64 in range(_size60):
                        _elem65 = KvDependency()
                        _elem65.read(iprot)
                        self.kvDependency.append(_elem65)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 201:
                if ftype == TType.I64:
                    self.kvPollIntervalMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecutionInfo')
        if self.env is not None:
            oprot.writeFieldBegin('env', TType.STRUCT, 1)
            self.env.write(oprot)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.STRUCT, 2)
            self.conf.write(oprot)
            oprot.writeFieldEnd()
        if self.dependencyPollIntervalMillis is not None:
            oprot.writeFieldBegin('dependencyPollIntervalMillis', TType.I64, 3)
            oprot.writeI64(self.dependencyPollIntervalMillis)
            oprot.writeFieldEnd()
        if self.healthCheckIntervalMillis is not None:
            oprot.writeFieldBegin('healthCheckIntervalMillis', TType.I64, 4)
            oprot.writeI64(self.healthCheckIntervalMillis)
            oprot.writeFieldEnd()
        if self.scheduleCron is not None:
            oprot.writeFieldBegin('scheduleCron', TType.STRING, 10)
            oprot.writeString(self.scheduleCron.encode('utf-8') if sys.version_info[0] == 2 else self.scheduleCron)
            oprot.writeFieldEnd()
        if self.stepDays is not None:
            oprot.writeFieldBegin('stepDays', TType.I32, 11)
            oprot.writeI32(self.stepDays)
            oprot.writeFieldEnd()
        if self.historicalBackfill is not None:
            oprot.writeFieldBegin('historicalBackfill', TType.BOOL, 12)
            oprot.writeBool(self.historicalBackfill)
            oprot.writeFieldEnd()
        if self.tableDependencies is not None:
            oprot.writeFieldBegin('tableDependencies', TType.LIST, 13)
            oprot.writeListBegin(TType.STRUCT, len(self.tableDependencies))
            for iter66 in self.tableDependencies:
                iter66.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.outputTableInfo is not None:
            oprot.writeFieldBegin('outputTableInfo', TType.STRUCT, 14)
            self.outputTableInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.kvDependency is not None:
            oprot.writeFieldBegin('kvDependency', TType.LIST, 200)
            oprot.writeListBegin(TType.STRUCT, len(self.kvDependency))
            for iter67 in self.kvDependency:
                iter67.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.kvPollIntervalMillis is not None:
            oprot.writeFieldBegin('kvPollIntervalMillis', TType.I64, 201)
            oprot.writeI64(self.kvPollIntervalMillis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Window)
Window.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'length', None, None, ),  # 1
    (2, TType.I32, 'timeUnit', None, None, ),  # 2
)
all_structs.append(DateRange)
DateRange.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'startDate', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'endDate', 'UTF8', None, ),  # 2
)
all_structs.append(EnvironmentVariables)
EnvironmentVariables.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'common', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.MAP, 'modeEnvironments', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 2
)
all_structs.append(ConfigProperties)
ConfigProperties.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'common', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.MAP, 'modeConfigs', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 2
)
all_structs.append(TableInfo)
TableInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table', 'UTF8', None, ),  # 1
    None,  # 2
    None,  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    (100, TType.STRING, 'partitionColumn', 'UTF8', None, ),  # 100
    (101, TType.STRING, 'partitionFormat', 'UTF8', None, ),  # 101
    (102, TType.STRUCT, 'partitionInterval', [Window, None], None, ),  # 102
    None,  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    (200, TType.BOOL, 'isCumulative', None, None, ),  # 200
)
all_structs.append(TableDependency)
TableDependency.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tableInfo', [TableInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'startOffset', [Window, None], None, ),  # 2
    (3, TType.STRUCT, 'endOffset', [Window, None], None, ),  # 3
    (4, TType.STRING, 'startCutOff', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'endCutOff', 'UTF8', None, ),  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    None,  # 100
    None,  # 101
    None,  # 102
    None,  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    None,  # 200
    (201, TType.BOOL, 'forceCompute', None, None, ),  # 201
)
all_structs.append(KvDependency)
KvDependency.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cluster', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'keyBase64', 'UTF8', None, ),  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.I64, 'startMillis', None, None, ),  # 10
    (11, TType.I64, 'endMillis', None, None, ),  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.I32, 'scanStrategy', None, None, ),  # 20
)
all_structs.append(ExecutionInfo)
ExecutionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'env', [EnvironmentVariables, None], None, ),  # 1
    (2, TType.STRUCT, 'conf', [ConfigProperties, None], None, ),  # 2
    (3, TType.I64, 'dependencyPollIntervalMillis', None, None, ),  # 3
    (4, TType.I64, 'healthCheckIntervalMillis', None, None, ),  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.STRING, 'scheduleCron', 'UTF8', None, ),  # 10
    (11, TType.I32, 'stepDays', None, None, ),  # 11
    (12, TType.BOOL, 'historicalBackfill', None, None, ),  # 12
    (13, TType.LIST, 'tableDependencies', (TType.STRUCT, [TableDependency, None], False), None, ),  # 13
    (14, TType.STRUCT, 'outputTableInfo', [TableInfo, None], None, ),  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    None,  # 100
    None,  # 101
    None,  # 102
    None,  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    (200, TType.LIST, 'kvDependency', (TType.STRUCT, [KvDependency, None], False), None, ),  # 200
    (201, TType.I64, 'kvPollIntervalMillis', None, None, ),  # 201
)
fix_spec(all_structs)
del all_structs
