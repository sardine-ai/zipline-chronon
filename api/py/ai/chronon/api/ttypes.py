#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import ai.chronon.api.common.ttypes
import ai.chronon.observability.ttypes

from thrift.transport import TTransport
all_structs = []


class Operation(object):
    MIN = 0
    MAX = 1
    FIRST = 2
    LAST = 3
    UNIQUE_COUNT = 4
    APPROX_UNIQUE_COUNT = 5
    COUNT = 6
    SUM = 7
    AVERAGE = 8
    VARIANCE = 9
    SKEW = 10
    KURTOSIS = 11
    APPROX_PERCENTILE = 12
    LAST_K = 13
    FIRST_K = 14
    TOP_K = 15
    BOTTOM_K = 16
    HISTOGRAM = 17
    APPROX_FREQUENT_K = 18
    APPROX_HEAVY_HITTERS_K = 19

    _VALUES_TO_NAMES = {
        0: "MIN",
        1: "MAX",
        2: "FIRST",
        3: "LAST",
        4: "UNIQUE_COUNT",
        5: "APPROX_UNIQUE_COUNT",
        6: "COUNT",
        7: "SUM",
        8: "AVERAGE",
        9: "VARIANCE",
        10: "SKEW",
        11: "KURTOSIS",
        12: "APPROX_PERCENTILE",
        13: "LAST_K",
        14: "FIRST_K",
        15: "TOP_K",
        16: "BOTTOM_K",
        17: "HISTOGRAM",
        18: "APPROX_FREQUENT_K",
        19: "APPROX_HEAVY_HITTERS_K",
    }

    _NAMES_TO_VALUES = {
        "MIN": 0,
        "MAX": 1,
        "FIRST": 2,
        "LAST": 3,
        "UNIQUE_COUNT": 4,
        "APPROX_UNIQUE_COUNT": 5,
        "COUNT": 6,
        "SUM": 7,
        "AVERAGE": 8,
        "VARIANCE": 9,
        "SKEW": 10,
        "KURTOSIS": 11,
        "APPROX_PERCENTILE": 12,
        "LAST_K": 13,
        "FIRST_K": 14,
        "TOP_K": 15,
        "BOTTOM_K": 16,
        "HISTOGRAM": 17,
        "APPROX_FREQUENT_K": 18,
        "APPROX_HEAVY_HITTERS_K": 19,
    }


class Accuracy(object):
    TEMPORAL = 0
    SNAPSHOT = 1

    _VALUES_TO_NAMES = {
        0: "TEMPORAL",
        1: "SNAPSHOT",
    }

    _NAMES_TO_VALUES = {
        "TEMPORAL": 0,
        "SNAPSHOT": 1,
    }


class EngineType(object):
    SPARK = 0
    BIGQUERY = 1

    _VALUES_TO_NAMES = {
        0: "SPARK",
        1: "BIGQUERY",
    }

    _NAMES_TO_VALUES = {
        "SPARK": 0,
        "BIGQUERY": 1,
    }


class DataKind(object):
    BOOLEAN = 0
    BYTE = 1
    SHORT = 2
    INT = 3
    LONG = 4
    FLOAT = 5
    DOUBLE = 6
    STRING = 7
    BINARY = 8
    DATE = 9
    TIMESTAMP = 10
    MAP = 11
    LIST = 12
    STRUCT = 13

    _VALUES_TO_NAMES = {
        0: "BOOLEAN",
        1: "BYTE",
        2: "SHORT",
        3: "INT",
        4: "LONG",
        5: "FLOAT",
        6: "DOUBLE",
        7: "STRING",
        8: "BINARY",
        9: "DATE",
        10: "TIMESTAMP",
        11: "MAP",
        12: "LIST",
        13: "STRUCT",
    }

    _NAMES_TO_VALUES = {
        "BOOLEAN": 0,
        "BYTE": 1,
        "SHORT": 2,
        "INT": 3,
        "LONG": 4,
        "FLOAT": 5,
        "DOUBLE": 6,
        "STRING": 7,
        "BINARY": 8,
        "DATE": 9,
        "TIMESTAMP": 10,
        "MAP": 11,
        "LIST": 12,
        "STRUCT": 13,
    }


class ModelType(object):
    XGBoost = 0
    PyTorch = 1
    TensorFlow = 2
    ScikitLearn = 3
    LightGBM = 4
    Other = 100

    _VALUES_TO_NAMES = {
        0: "XGBoost",
        1: "PyTorch",
        2: "TensorFlow",
        3: "ScikitLearn",
        4: "LightGBM",
        100: "Other",
    }

    _NAMES_TO_VALUES = {
        "XGBoost": 0,
        "PyTorch": 1,
        "TensorFlow": 2,
        "ScikitLearn": 3,
        "LightGBM": 4,
        "Other": 100,
    }


class DataModel(object):
    ENTITIES = 0
    EVENTS = 1

    _VALUES_TO_NAMES = {
        0: "ENTITIES",
        1: "EVENTS",
    }

    _NAMES_TO_VALUES = {
        "ENTITIES": 0,
        "EVENTS": 1,
    }


class Query(object):
    """
    Attributes:
     - selects
     - wheres
     - startPartition
     - endPartition
     - timeColumn
     - setups
     - mutationTimeColumn
     - reversalColumn
     - partitionColumn

    """


    def __init__(self, selects=None, wheres=None, startPartition=None, endPartition=None, timeColumn=None, setups=None, mutationTimeColumn=None, reversalColumn=None, partitionColumn=None,):
        self.selects = selects
        self.wheres = wheres
        self.startPartition = startPartition
        self.endPartition = endPartition
        self.timeColumn = timeColumn
        self.setups = setups
        self.mutationTimeColumn = mutationTimeColumn
        self.reversalColumn = reversalColumn
        self.partitionColumn = partitionColumn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.selects = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.selects[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.wheres = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.wheres.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endPartition = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.timeColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.setups = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.setups.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.mutationTimeColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.reversalColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.partitionColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Query')
        if self.selects is not None:
            oprot.writeFieldBegin('selects', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.selects))
            for kiter19, viter20 in self.selects.items():
                oprot.writeString(kiter19.encode('utf-8') if sys.version_info[0] == 2 else kiter19)
                oprot.writeString(viter20.encode('utf-8') if sys.version_info[0] == 2 else viter20)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.wheres is not None:
            oprot.writeFieldBegin('wheres', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.wheres))
            for iter21 in self.wheres:
                oprot.writeString(iter21.encode('utf-8') if sys.version_info[0] == 2 else iter21)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 3)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.endPartition is not None:
            oprot.writeFieldBegin('endPartition', TType.STRING, 4)
            oprot.writeString(self.endPartition.encode('utf-8') if sys.version_info[0] == 2 else self.endPartition)
            oprot.writeFieldEnd()
        if self.timeColumn is not None:
            oprot.writeFieldBegin('timeColumn', TType.STRING, 5)
            oprot.writeString(self.timeColumn.encode('utf-8') if sys.version_info[0] == 2 else self.timeColumn)
            oprot.writeFieldEnd()
        if self.setups is not None:
            oprot.writeFieldBegin('setups', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.setups))
            for iter22 in self.setups:
                oprot.writeString(iter22.encode('utf-8') if sys.version_info[0] == 2 else iter22)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mutationTimeColumn is not None:
            oprot.writeFieldBegin('mutationTimeColumn', TType.STRING, 7)
            oprot.writeString(self.mutationTimeColumn.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTimeColumn)
            oprot.writeFieldEnd()
        if self.reversalColumn is not None:
            oprot.writeFieldBegin('reversalColumn', TType.STRING, 8)
            oprot.writeString(self.reversalColumn.encode('utf-8') if sys.version_info[0] == 2 else self.reversalColumn)
            oprot.writeFieldEnd()
        if self.partitionColumn is not None:
            oprot.writeFieldBegin('partitionColumn', TType.STRING, 9)
            oprot.writeString(self.partitionColumn.encode('utf-8') if sys.version_info[0] == 2 else self.partitionColumn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StagingQuery(object):
    """
    Staging Query encapsulates arbitrary spark computation. One key feature is that the computation follows a
    "fill-what's-missing" pattern. Basically instead of explicitly specifying dates you specify two macros.
    `{{ start_date }}` and `{{end_date}}`. Chronon will pass in earliest-missing-partition for `start_date` and
    execution-date / today for `end_date`. So the query will compute multiple partitions at once.

    Attributes:
     - metaData: Contains name, team, output_namespace, execution parameters etc. Things that don't change the semantics of the computation itself.

     - query: Arbitrary spark query that should be written with `{{ start_date }}`, `{{ end_date }}` and `{{ latest_date }}` templates
         - `{{ start_date }}` will be set to this user provided start date, future incremental runs will set it to the latest existing partition + 1 day.
         - `{{ start_date(offset=-10, lower_bound='2023-01-01', upper_bound='2024-01-01') }}` will shift the date back one day and bound it with lower and upper bounds.
         - `{{ end_date }}` is the end partition of the computing range. offsetting and bounding the end_date also works as described above.
         - `{{ latest_date }}` is the end partition independent of the computing range (meant for cumulative sources). offsetting and bounding the end_date also works as described above.
         - `{{ max_date(table=namespace.my_table) }}` is the max partition available for a given table.


     - startPartition: on the first run, `{{ start_date }}` will be set to this user provided start date, future incremental runs will set it to the latest existing partition + 1 day.

     - setups: Spark SQL setup statements. Used typically to register UDFs.

     - partitionColumn: Only needed for `max_date` template

     - engineType: By default, spark is the compute engine. You can specify an override (eg. bigquery, etc.)


    """


    def __init__(self, metaData=None, query=None, startPartition=None, setups=None, partitionColumn=None, engineType=None,):
        self.metaData = metaData
        self.query = query
        self.startPartition = startPartition
        self.setups = setups
        self.partitionColumn = partitionColumn
        self.engineType = engineType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.setups = []
                    (_etype26, _size23) = iprot.readListBegin()
                    for _i27 in range(_size23):
                        _elem28 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.setups.append(_elem28)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.partitionColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.engineType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StagingQuery')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 3)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.setups is not None:
            oprot.writeFieldBegin('setups', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.setups))
            for iter29 in self.setups:
                oprot.writeString(iter29.encode('utf-8') if sys.version_info[0] == 2 else iter29)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partitionColumn is not None:
            oprot.writeFieldBegin('partitionColumn', TType.STRING, 5)
            oprot.writeString(self.partitionColumn.encode('utf-8') if sys.version_info[0] == 2 else self.partitionColumn)
            oprot.writeFieldEnd()
        if self.engineType is not None:
            oprot.writeFieldBegin('engineType', TType.I32, 6)
            oprot.writeI32(self.engineType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EventSource(object):
    """
    Attributes:
     - table: Table currently needs to be a 'ds' (date string - yyyy-MM-dd) partitioned hive table. Table names can contain subpartition specs, example db.table/system=mobile/currency=USD

     - topic: Topic is a kafka table. The table contains all the events historically came through this topic.

     - query: The logic used to scan both the table and the topic. Contains row level transformations and filtering expressed as Spark SQL statements.

     - isCumulative: If each new hive partition contains not just the current day's events but the entire set of events since the begininng. The key property is that the events are not mutated across partitions.


    """


    def __init__(self, table=None, topic=None, query=None, isCumulative=None,):
        self.table = table
        self.topic = topic
        self.query = query
        self.isCumulative = isCumulative

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.topic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isCumulative = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EventSource')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 1)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.topic is not None:
            oprot.writeFieldBegin('topic', TType.STRING, 2)
            oprot.writeString(self.topic.encode('utf-8') if sys.version_info[0] == 2 else self.topic)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 3)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        if self.isCumulative is not None:
            oprot.writeFieldBegin('isCumulative', TType.BOOL, 4)
            oprot.writeBool(self.isCumulative)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EntitySource(object):
    """
    Entity Sources represent data that gets mutated over-time - at row-level. This is a group of three data elements.
    snapshotTable, mutationTable and mutationTopic. mutationTable and mutationTopic are only necessary if we are trying
    to create realtime or point-in-time aggregations over these sources. Entity sources usually map 1:1 with a database
    tables in your OLTP store that typically serves live application traffic. When mutation data is absent they map 1:1
    to `dim` tables in star schema.

    Attributes:
     - snapshotTable: Snapshot table currently needs to be a 'ds' (date string - yyyy-MM-dd) partitioned hive table.
     - mutationTable: Topic is a kafka table. The table contains all the events that historically came through this topic.
     - mutationTopic: The logic used to scan both the table and the topic. Contains row level transformations and filtering expressed as Spark SQL statements.
     - query: If each new hive partition contains not just the current day's events but the entire set of events since the begininng. The key property is that the events are not mutated across partitions.

    """


    def __init__(self, snapshotTable=None, mutationTable=None, mutationTopic=None, query=None,):
        self.snapshotTable = snapshotTable
        self.mutationTable = mutationTable
        self.mutationTopic = mutationTopic
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snapshotTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mutationTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mutationTopic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EntitySource')
        if self.snapshotTable is not None:
            oprot.writeFieldBegin('snapshotTable', TType.STRING, 1)
            oprot.writeString(self.snapshotTable.encode('utf-8') if sys.version_info[0] == 2 else self.snapshotTable)
            oprot.writeFieldEnd()
        if self.mutationTable is not None:
            oprot.writeFieldBegin('mutationTable', TType.STRING, 2)
            oprot.writeString(self.mutationTable.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTable)
            oprot.writeFieldEnd()
        if self.mutationTopic is not None:
            oprot.writeFieldBegin('mutationTopic', TType.STRING, 3)
            oprot.writeString(self.mutationTopic.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTopic)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 4)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExternalSource(object):
    """
    Attributes:
     - metadata
     - keySchema
     - valueSchema

    """


    def __init__(self, metadata=None, keySchema=None, valueSchema=None,):
        self.metadata = metadata
        self.keySchema = keySchema
        self.valueSchema = valueSchema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metadata = MetaData()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.keySchema = TDataType()
                    self.keySchema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.valueSchema = TDataType()
                    self.valueSchema.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExternalSource')
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 1)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.keySchema is not None:
            oprot.writeFieldBegin('keySchema', TType.STRUCT, 2)
            self.keySchema.write(oprot)
            oprot.writeFieldEnd()
        if self.valueSchema is not None:
            oprot.writeFieldBegin('valueSchema', TType.STRUCT, 3)
            self.valueSchema.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinSource(object):
    """
    Output of a Join can be used as input to downstream computations like GroupBy or a Join.
    Below is a short description of each of the cases we handle.
    Case #1: a join's source is another join [TODO]
      - while serving, we expect the keys for the upstream join to be passed in the request.
        we will query upstream first, and use the result to query downstream
      - while backfill, we will backfill the upstream first, and use the table as the left of the subsequent join
      - this is currently a "to do" because users can achieve this by themselves unlike case 2:
    Case #2: a join is the source of another GroupBy
      - We will support arbitrarily long transformation chains with this.
      - for batch (Accuracy.SNAPSHOT), we simply backfill the join first and compute groupBy as usual
        - will substitute the joinSource with the resulting table and continue computation
        - we will add a "resolve source" step prior to backfills that will compute the parent join and update the source
      - for realtime (Accuracy.TEMPORAL), we need to do "stream enrichment"
        - we will simply issue "fetchJoin" and create an enriched source. Note the join left should be of type "events".


    Attributes:
     - join
     - query

    """


    def __init__(self, join=None, query=None,):
        self.join = join
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.join = Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinSource')
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 1)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 2)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Source(object):
    """
    Attributes:
     - events
     - entities
     - joinSource

    """


    def __init__(self, events=None, entities=None, joinSource=None,):
        self.events = events
        self.entities = entities
        self.joinSource = joinSource

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.events = EventSource()
                    self.events.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.entities = EntitySource()
                    self.entities.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.joinSource = JoinSource()
                    self.joinSource.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Source')
        if self.events is not None:
            oprot.writeFieldBegin('events', TType.STRUCT, 1)
            self.events.write(oprot)
            oprot.writeFieldEnd()
        if self.entities is not None:
            oprot.writeFieldBegin('entities', TType.STRUCT, 2)
            self.entities.write(oprot)
            oprot.writeFieldEnd()
        if self.joinSource is not None:
            oprot.writeFieldBegin('joinSource', TType.STRUCT, 3)
            self.joinSource.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Aggregation(object):
    """
    Chronon provides a powerful aggregations primitive - that takes the familiar aggregation operation, via groupBy in
    SQL and extends it with three things - windowing, bucketing and auto-explode.

    Attributes:
     - inputColumn: The column as specified in source.query.selects - on which we need to aggregate with.

     - operation: The type of aggregation that needs to be performed on the inputColumn.

     - argMap: Extra arguments that needs to be passed to some of the operations like LAST_K, APPROX_PERCENTILE.

     - windows: For TEMPORAL case windows are sawtooth. Meaning head slides ahead continuously in time, whereas, the tail only hops ahead, at discrete points in time. Hop is determined by the window size automatically. The maximum hop size is 1/12 of window size. You can specify multiple such windows at once.
      - Window > 12 days  -> Hop Size = 1 day
      - Window > 12 hours -> Hop Size = 1 hr
      - Window > 1hr      -> Hop Size = 5 minutes
     - buckets: This is an additional layer of aggregation. You can key a group_by by user, and bucket a “item_view” count by “item_category”. This will produce one row per user, with column containing map of “item_category” to “view_count”. You can specify multiple such buckets at once

    """


    def __init__(self, inputColumn=None, operation=None, argMap=None, windows=None, buckets=None,):
        self.inputColumn = inputColumn
        self.operation = operation
        self.argMap = argMap
        self.windows = windows
        self.buckets = buckets

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.inputColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.argMap = {}
                    (_ktype31, _vtype32, _size30) = iprot.readMapBegin()
                    for _i34 in range(_size30):
                        _key35 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val36 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.argMap[_key35] = _val36
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.windows = []
                    (_etype40, _size37) = iprot.readListBegin()
                    for _i41 in range(_size37):
                        _elem42 = ai.chronon.api.common.ttypes.Window()
                        _elem42.read(iprot)
                        self.windows.append(_elem42)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.buckets = []
                    (_etype46, _size43) = iprot.readListBegin()
                    for _i47 in range(_size43):
                        _elem48 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.buckets.append(_elem48)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Aggregation')
        if self.inputColumn is not None:
            oprot.writeFieldBegin('inputColumn', TType.STRING, 1)
            oprot.writeString(self.inputColumn.encode('utf-8') if sys.version_info[0] == 2 else self.inputColumn)
            oprot.writeFieldEnd()
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.I32, 2)
            oprot.writeI32(self.operation)
            oprot.writeFieldEnd()
        if self.argMap is not None:
            oprot.writeFieldBegin('argMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.argMap))
            for kiter49, viter50 in self.argMap.items():
                oprot.writeString(kiter49.encode('utf-8') if sys.version_info[0] == 2 else kiter49)
                oprot.writeString(viter50.encode('utf-8') if sys.version_info[0] == 2 else viter50)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.windows is not None:
            oprot.writeFieldBegin('windows', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.windows))
            for iter51 in self.windows:
                iter51.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.buckets is not None:
            oprot.writeFieldBegin('buckets', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.buckets))
            for iter52 in self.buckets:
                oprot.writeString(iter52.encode('utf-8') if sys.version_info[0] == 2 else iter52)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AggregationPart(object):
    """
    Attributes:
     - inputColumn
     - operation
     - argMap
     - window
     - bucket

    """


    def __init__(self, inputColumn=None, operation=None, argMap=None, window=None, bucket=None,):
        self.inputColumn = inputColumn
        self.operation = operation
        self.argMap = argMap
        self.window = window
        self.bucket = bucket

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.inputColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.argMap = {}
                    (_ktype54, _vtype55, _size53) = iprot.readMapBegin()
                    for _i57 in range(_size53):
                        _key58 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val59 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.argMap[_key58] = _val59
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.window = ai.chronon.api.common.ttypes.Window()
                    self.window.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.bucket = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AggregationPart')
        if self.inputColumn is not None:
            oprot.writeFieldBegin('inputColumn', TType.STRING, 1)
            oprot.writeString(self.inputColumn.encode('utf-8') if sys.version_info[0] == 2 else self.inputColumn)
            oprot.writeFieldEnd()
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.I32, 2)
            oprot.writeI32(self.operation)
            oprot.writeFieldEnd()
        if self.argMap is not None:
            oprot.writeFieldBegin('argMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.argMap))
            for kiter60, viter61 in self.argMap.items():
                oprot.writeString(kiter60.encode('utf-8') if sys.version_info[0] == 2 else kiter60)
                oprot.writeString(viter61.encode('utf-8') if sys.version_info[0] == 2 else viter61)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.window is not None:
            oprot.writeFieldBegin('window', TType.STRUCT, 4)
            self.window.write(oprot)
            oprot.writeFieldEnd()
        if self.bucket is not None:
            oprot.writeFieldBegin('bucket', TType.STRING, 5)
            oprot.writeString(self.bucket.encode('utf-8') if sys.version_info[0] == 2 else self.bucket)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MetaData(object):
    """
    contains configs params that don't change the contents of the output.


    Attributes:
     - name
     - team
     - version
     - outputNamespace
     - additionalOutputPartitionColumns: By default we will just partition the output by the date column - set via "spark.chronon.partition.column"
    With this we will partition the output with the specified additional columns

     - tableProperties
     - tags
     - columnTags
     - online
     - production
     - sourceFile
     - customJson
     - consistencyCheck
     - samplePercent
     - consistencySamplePercent
     - driftSpec
     - executionInfo

    """


    def __init__(self, name=None, team=None, version=None, outputNamespace=None, additionalOutputPartitionColumns=None, tableProperties=None, tags=None, columnTags=None, online=None, production=None, sourceFile=None, customJson=None, consistencyCheck=None, samplePercent=None, consistencySamplePercent=None, driftSpec=None, executionInfo=None,):
        self.name = name
        self.team = team
        self.version = version
        self.outputNamespace = outputNamespace
        self.additionalOutputPartitionColumns = additionalOutputPartitionColumns
        self.tableProperties = tableProperties
        self.tags = tags
        self.columnTags = columnTags
        self.online = online
        self.production = production
        self.sourceFile = sourceFile
        self.customJson = customJson
        self.consistencyCheck = consistencyCheck
        self.samplePercent = samplePercent
        self.consistencySamplePercent = consistencySamplePercent
        self.driftSpec = driftSpec
        self.executionInfo = executionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.team = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.outputNamespace = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.additionalOutputPartitionColumns = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.additionalOutputPartitionColumns.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.tableProperties = {}
                    (_ktype69, _vtype70, _size68) = iprot.readMapBegin()
                    for _i72 in range(_size68):
                        _key73 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val74 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tableProperties[_key73] = _val74
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.MAP:
                    self.tags = {}
                    (_ktype76, _vtype77, _size75) = iprot.readMapBegin()
                    for _i79 in range(_size75):
                        _key80 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val81 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tags[_key80] = _val81
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.MAP:
                    self.columnTags = {}
                    (_ktype83, _vtype84, _size82) = iprot.readMapBegin()
                    for _i86 in range(_size82):
                        _key87 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val88 = {}
                        (_ktype90, _vtype91, _size89) = iprot.readMapBegin()
                        for _i93 in range(_size89):
                            _key94 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val95 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val88[_key94] = _val95
                        iprot.readMapEnd()
                        self.columnTags[_key87] = _val88
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.BOOL:
                    self.online = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.BOOL:
                    self.production = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 102:
                if ftype == TType.STRING:
                    self.sourceFile = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 103:
                if ftype == TType.STRING:
                    self.customJson = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 200:
                if ftype == TType.BOOL:
                    self.consistencyCheck = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 201:
                if ftype == TType.DOUBLE:
                    self.samplePercent = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 202:
                if ftype == TType.DOUBLE:
                    self.consistencySamplePercent = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 203:
                if ftype == TType.STRUCT:
                    self.driftSpec = ai.chronon.observability.ttypes.DriftSpec()
                    self.driftSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 204:
                if ftype == TType.STRUCT:
                    self.executionInfo = ai.chronon.api.common.ttypes.ExecutionInfo()
                    self.executionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MetaData')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.team is not None:
            oprot.writeFieldBegin('team', TType.STRING, 2)
            oprot.writeString(self.team.encode('utf-8') if sys.version_info[0] == 2 else self.team)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 3)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.outputNamespace is not None:
            oprot.writeFieldBegin('outputNamespace', TType.STRING, 4)
            oprot.writeString(self.outputNamespace.encode('utf-8') if sys.version_info[0] == 2 else self.outputNamespace)
            oprot.writeFieldEnd()
        if self.additionalOutputPartitionColumns is not None:
            oprot.writeFieldBegin('additionalOutputPartitionColumns', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.additionalOutputPartitionColumns))
            for iter96 in self.additionalOutputPartitionColumns:
                oprot.writeString(iter96.encode('utf-8') if sys.version_info[0] == 2 else iter96)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tableProperties is not None:
            oprot.writeFieldBegin('tableProperties', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tableProperties))
            for kiter97, viter98 in self.tableProperties.items():
                oprot.writeString(kiter97.encode('utf-8') if sys.version_info[0] == 2 else kiter97)
                oprot.writeString(viter98.encode('utf-8') if sys.version_info[0] == 2 else viter98)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.MAP, 20)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tags))
            for kiter99, viter100 in self.tags.items():
                oprot.writeString(kiter99.encode('utf-8') if sys.version_info[0] == 2 else kiter99)
                oprot.writeString(viter100.encode('utf-8') if sys.version_info[0] == 2 else viter100)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.columnTags is not None:
            oprot.writeFieldBegin('columnTags', TType.MAP, 21)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.columnTags))
            for kiter101, viter102 in self.columnTags.items():
                oprot.writeString(kiter101.encode('utf-8') if sys.version_info[0] == 2 else kiter101)
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter102))
                for kiter103, viter104 in viter102.items():
                    oprot.writeString(kiter103.encode('utf-8') if sys.version_info[0] == 2 else kiter103)
                    oprot.writeString(viter104.encode('utf-8') if sys.version_info[0] == 2 else viter104)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.online is not None:
            oprot.writeFieldBegin('online', TType.BOOL, 100)
            oprot.writeBool(self.online)
            oprot.writeFieldEnd()
        if self.production is not None:
            oprot.writeFieldBegin('production', TType.BOOL, 101)
            oprot.writeBool(self.production)
            oprot.writeFieldEnd()
        if self.sourceFile is not None:
            oprot.writeFieldBegin('sourceFile', TType.STRING, 102)
            oprot.writeString(self.sourceFile.encode('utf-8') if sys.version_info[0] == 2 else self.sourceFile)
            oprot.writeFieldEnd()
        if self.customJson is not None:
            oprot.writeFieldBegin('customJson', TType.STRING, 103)
            oprot.writeString(self.customJson.encode('utf-8') if sys.version_info[0] == 2 else self.customJson)
            oprot.writeFieldEnd()
        if self.consistencyCheck is not None:
            oprot.writeFieldBegin('consistencyCheck', TType.BOOL, 200)
            oprot.writeBool(self.consistencyCheck)
            oprot.writeFieldEnd()
        if self.samplePercent is not None:
            oprot.writeFieldBegin('samplePercent', TType.DOUBLE, 201)
            oprot.writeDouble(self.samplePercent)
            oprot.writeFieldEnd()
        if self.consistencySamplePercent is not None:
            oprot.writeFieldBegin('consistencySamplePercent', TType.DOUBLE, 202)
            oprot.writeDouble(self.consistencySamplePercent)
            oprot.writeFieldEnd()
        if self.driftSpec is not None:
            oprot.writeFieldBegin('driftSpec', TType.STRUCT, 203)
            self.driftSpec.write(oprot)
            oprot.writeFieldEnd()
        if self.executionInfo is not None:
            oprot.writeFieldBegin('executionInfo', TType.STRUCT, 204)
            self.executionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupBy(object):
    """
    Attributes:
     - metaData
     - sources
     - keyColumns
     - aggregations
     - accuracy
     - backfillStartDate
     - derivations

    """


    def __init__(self, metaData=None, sources=None, keyColumns=None, aggregations=None, accuracy=None, backfillStartDate=None, derivations=None,):
        self.metaData = metaData
        self.sources = sources
        self.keyColumns = keyColumns
        self.aggregations = aggregations
        self.accuracy = accuracy
        self.backfillStartDate = backfillStartDate
        self.derivations = derivations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sources = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = Source()
                        _elem110.read(iprot)
                        self.sources.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.keyColumns = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyColumns.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.aggregations = []
                    (_etype120, _size117) = iprot.readListBegin()
                    for _i121 in range(_size117):
                        _elem122 = Aggregation()
                        _elem122.read(iprot)
                        self.aggregations.append(_elem122)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.accuracy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.backfillStartDate = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.derivations = []
                    (_etype126, _size123) = iprot.readListBegin()
                    for _i127 in range(_size123):
                        _elem128 = Derivation()
                        _elem128.read(iprot)
                        self.derivations.append(_elem128)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupBy')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.sources is not None:
            oprot.writeFieldBegin('sources', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.sources))
            for iter129 in self.sources:
                iter129.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keyColumns is not None:
            oprot.writeFieldBegin('keyColumns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.keyColumns))
            for iter130 in self.keyColumns:
                oprot.writeString(iter130.encode('utf-8') if sys.version_info[0] == 2 else iter130)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregations is not None:
            oprot.writeFieldBegin('aggregations', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.aggregations))
            for iter131 in self.aggregations:
                iter131.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.accuracy is not None:
            oprot.writeFieldBegin('accuracy', TType.I32, 5)
            oprot.writeI32(self.accuracy)
            oprot.writeFieldEnd()
        if self.backfillStartDate is not None:
            oprot.writeFieldBegin('backfillStartDate', TType.STRING, 6)
            oprot.writeString(self.backfillStartDate.encode('utf-8') if sys.version_info[0] == 2 else self.backfillStartDate)
            oprot.writeFieldEnd()
        if self.derivations is not None:
            oprot.writeFieldBegin('derivations', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.derivations))
            for iter132 in self.derivations:
                iter132.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinPart(object):
    """
    Attributes:
     - groupBy
     - keyMapping
     - prefix

    """


    def __init__(self, groupBy=None, keyMapping=None, prefix=None,):
        self.groupBy = groupBy
        self.keyMapping = keyMapping
        self.prefix = prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.groupBy = GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.keyMapping = {}
                    (_ktype134, _vtype135, _size133) = iprot.readMapBegin()
                    for _i137 in range(_size133):
                        _key138 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val139 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyMapping[_key138] = _val139
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.prefix = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinPart')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 1)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        if self.keyMapping is not None:
            oprot.writeFieldBegin('keyMapping', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyMapping))
            for kiter140, viter141 in self.keyMapping.items():
                oprot.writeString(kiter140.encode('utf-8') if sys.version_info[0] == 2 else kiter140)
                oprot.writeString(viter141.encode('utf-8') if sys.version_info[0] == 2 else viter141)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.prefix is not None:
            oprot.writeFieldBegin('prefix', TType.STRING, 3)
            oprot.writeString(self.prefix.encode('utf-8') if sys.version_info[0] == 2 else self.prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExternalPart(object):
    """
    Attributes:
     - source
     - keyMapping
     - prefix

    """


    def __init__(self, source=None, keyMapping=None, prefix=None,):
        self.source = source
        self.keyMapping = keyMapping
        self.prefix = prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.source = ExternalSource()
                    self.source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.keyMapping = {}
                    (_ktype143, _vtype144, _size142) = iprot.readMapBegin()
                    for _i146 in range(_size142):
                        _key147 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val148 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyMapping[_key147] = _val148
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.prefix = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExternalPart')
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRUCT, 1)
            self.source.write(oprot)
            oprot.writeFieldEnd()
        if self.keyMapping is not None:
            oprot.writeFieldBegin('keyMapping', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyMapping))
            for kiter149, viter150 in self.keyMapping.items():
                oprot.writeString(kiter149.encode('utf-8') if sys.version_info[0] == 2 else kiter149)
                oprot.writeString(viter150.encode('utf-8') if sys.version_info[0] == 2 else viter150)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.prefix is not None:
            oprot.writeFieldBegin('prefix', TType.STRING, 3)
            oprot.writeString(self.prefix.encode('utf-8') if sys.version_info[0] == 2 else self.prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Derivation(object):
    """
    Attributes:
     - name
     - expression

    """


    def __init__(self, name=None, expression=None,):
        self.name = name
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Derivation')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 2)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Join(object):
    """
    Attributes:
     - metaData
     - left
     - joinParts
     - skewKeys
     - onlineExternalParts
     - labelParts
     - bootstrapParts
     - rowIds
     - derivations: List of a derived column names to the expression based on joinPart / externalPart columns
    The expression can be any valid Spark SQL select clause without aggregation functions.

    joinPart column names are automatically constructed according to the below convention
     `{join_part_prefix}_{group_by_name}_{input_column_name}_{aggregation_operation}_{window}_{by_bucket}`
     prefix, window and bucket are optional. You can find the type information of columns using the analyzer tool.

    externalPart column names are automatically constructed according to the below convention
     `ext_{external_source_name}_{value_column}`
    Types are defined along with the schema by users for external sources.

    Including a column with key "*" and value "*", means that every raw column will be included along with the derived
    columns.

     - useLongNames

    """


    def __init__(self, metaData=None, left=None, joinParts=None, skewKeys=None, onlineExternalParts=None, labelParts=None, bootstrapParts=None, rowIds=None, derivations=None, useLongNames=None,):
        self.metaData = metaData
        self.left = left
        self.joinParts = joinParts
        self.skewKeys = skewKeys
        self.onlineExternalParts = onlineExternalParts
        self.labelParts = labelParts
        self.bootstrapParts = bootstrapParts
        self.rowIds = rowIds
        self.derivations = derivations
        self.useLongNames = useLongNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.left = Source()
                    self.left.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.joinParts = []
                    (_etype154, _size151) = iprot.readListBegin()
                    for _i155 in range(_size151):
                        _elem156 = JoinPart()
                        _elem156.read(iprot)
                        self.joinParts.append(_elem156)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.skewKeys = {}
                    (_ktype158, _vtype159, _size157) = iprot.readMapBegin()
                    for _i161 in range(_size157):
                        _key162 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val163 = []
                        (_etype167, _size164) = iprot.readListBegin()
                        for _i168 in range(_size164):
                            _elem169 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val163.append(_elem169)
                        iprot.readListEnd()
                        self.skewKeys[_key162] = _val163
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.onlineExternalParts = []
                    (_etype173, _size170) = iprot.readListBegin()
                    for _i174 in range(_size170):
                        _elem175 = ExternalPart()
                        _elem175.read(iprot)
                        self.onlineExternalParts.append(_elem175)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.labelParts = LabelParts()
                    self.labelParts.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.bootstrapParts = []
                    (_etype179, _size176) = iprot.readListBegin()
                    for _i180 in range(_size176):
                        _elem181 = BootstrapPart()
                        _elem181.read(iprot)
                        self.bootstrapParts.append(_elem181)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.rowIds = []
                    (_etype185, _size182) = iprot.readListBegin()
                    for _i186 in range(_size182):
                        _elem187 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.rowIds.append(_elem187)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.derivations = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = Derivation()
                        _elem193.read(iprot)
                        self.derivations.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 50:
                if ftype == TType.BOOL:
                    self.useLongNames = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Join')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.STRUCT, 2)
            self.left.write(oprot)
            oprot.writeFieldEnd()
        if self.joinParts is not None:
            oprot.writeFieldBegin('joinParts', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.joinParts))
            for iter194 in self.joinParts:
                iter194.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.skewKeys is not None:
            oprot.writeFieldBegin('skewKeys', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.skewKeys))
            for kiter195, viter196 in self.skewKeys.items():
                oprot.writeString(kiter195.encode('utf-8') if sys.version_info[0] == 2 else kiter195)
                oprot.writeListBegin(TType.STRING, len(viter196))
                for iter197 in viter196:
                    oprot.writeString(iter197.encode('utf-8') if sys.version_info[0] == 2 else iter197)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.onlineExternalParts is not None:
            oprot.writeFieldBegin('onlineExternalParts', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.onlineExternalParts))
            for iter198 in self.onlineExternalParts:
                iter198.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.labelParts is not None:
            oprot.writeFieldBegin('labelParts', TType.STRUCT, 6)
            self.labelParts.write(oprot)
            oprot.writeFieldEnd()
        if self.bootstrapParts is not None:
            oprot.writeFieldBegin('bootstrapParts', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.bootstrapParts))
            for iter199 in self.bootstrapParts:
                iter199.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rowIds is not None:
            oprot.writeFieldBegin('rowIds', TType.LIST, 8)
            oprot.writeListBegin(TType.STRING, len(self.rowIds))
            for iter200 in self.rowIds:
                oprot.writeString(iter200.encode('utf-8') if sys.version_info[0] == 2 else iter200)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.derivations is not None:
            oprot.writeFieldBegin('derivations', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.derivations))
            for iter201 in self.derivations:
                iter201.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.useLongNames is not None:
            oprot.writeFieldBegin('useLongNames', TType.BOOL, 50)
            oprot.writeBool(self.useLongNames)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BootstrapPart(object):
    """
    Attributes:
     - metaData
     - table
     - query
     - keyColumns

    """


    def __init__(self, metaData=None, table=None, query=None, keyColumns=None,):
        self.metaData = metaData
        self.table = table
        self.query = query
        self.keyColumns = keyColumns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.keyColumns = []
                    (_etype205, _size202) = iprot.readListBegin()
                    for _i206 in range(_size202):
                        _elem207 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyColumns.append(_elem207)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BootstrapPart')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 2)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 3)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        if self.keyColumns is not None:
            oprot.writeFieldBegin('keyColumns', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.keyColumns))
            for iter208 in self.keyColumns:
                oprot.writeString(iter208.encode('utf-8') if sys.version_info[0] == 2 else iter208)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LabelParts(object):
    """
    Attributes:
     - labels
     - leftStartOffset
     - leftEndOffset
     - metaData

    """


    def __init__(self, labels=None, leftStartOffset=None, leftEndOffset=None, metaData=None,):
        self.labels = labels
        self.leftStartOffset = leftStartOffset
        self.leftEndOffset = leftEndOffset
        self.metaData = metaData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.labels = []
                    (_etype212, _size209) = iprot.readListBegin()
                    for _i213 in range(_size209):
                        _elem214 = JoinPart()
                        _elem214.read(iprot)
                        self.labels.append(_elem214)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.leftStartOffset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.leftEndOffset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LabelParts')
        if self.labels is not None:
            oprot.writeFieldBegin('labels', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.labels))
            for iter215 in self.labels:
                iter215.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.leftStartOffset is not None:
            oprot.writeFieldBegin('leftStartOffset', TType.I32, 2)
            oprot.writeI32(self.leftStartOffset)
            oprot.writeFieldEnd()
        if self.leftEndOffset is not None:
            oprot.writeFieldBegin('leftEndOffset', TType.I32, 3)
            oprot.writeI32(self.leftEndOffset)
            oprot.writeFieldEnd()
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 4)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupByServingInfo(object):
    """
    Attributes:
     - groupBy
     - inputAvroSchema
     - selectedAvroSchema
     - keyAvroSchema
     - batchEndDate
     - dateFormat

    """


    def __init__(self, groupBy=None, inputAvroSchema=None, selectedAvroSchema=None, keyAvroSchema=None, batchEndDate=None, dateFormat=None,):
        self.groupBy = groupBy
        self.inputAvroSchema = inputAvroSchema
        self.selectedAvroSchema = selectedAvroSchema
        self.keyAvroSchema = keyAvroSchema
        self.batchEndDate = batchEndDate
        self.dateFormat = dateFormat

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.groupBy = GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.inputAvroSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.selectedAvroSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.keyAvroSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.batchEndDate = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.dateFormat = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupByServingInfo')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 1)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        if self.inputAvroSchema is not None:
            oprot.writeFieldBegin('inputAvroSchema', TType.STRING, 2)
            oprot.writeString(self.inputAvroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.inputAvroSchema)
            oprot.writeFieldEnd()
        if self.selectedAvroSchema is not None:
            oprot.writeFieldBegin('selectedAvroSchema', TType.STRING, 3)
            oprot.writeString(self.selectedAvroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.selectedAvroSchema)
            oprot.writeFieldEnd()
        if self.keyAvroSchema is not None:
            oprot.writeFieldBegin('keyAvroSchema', TType.STRING, 4)
            oprot.writeString(self.keyAvroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.keyAvroSchema)
            oprot.writeFieldEnd()
        if self.batchEndDate is not None:
            oprot.writeFieldBegin('batchEndDate', TType.STRING, 5)
            oprot.writeString(self.batchEndDate.encode('utf-8') if sys.version_info[0] == 2 else self.batchEndDate)
            oprot.writeFieldEnd()
        if self.dateFormat is not None:
            oprot.writeFieldBegin('dateFormat', TType.STRING, 6)
            oprot.writeString(self.dateFormat.encode('utf-8') if sys.version_info[0] == 2 else self.dateFormat)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DataField(object):
    """
    Attributes:
     - name
     - dataType

    """


    def __init__(self, name=None, dataType=None,):
        self.name = name
        self.dataType = dataType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataType = TDataType()
                    self.dataType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DataField')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.STRUCT, 2)
            self.dataType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataType(object):
    """
    Attributes:
     - kind
     - params
     - name

    """


    def __init__(self, kind=None, params=None, name=None,):
        self.kind = kind
        self.params = params
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.kind = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.params = []
                    (_etype219, _size216) = iprot.readListBegin()
                    for _i220 in range(_size216):
                        _elem221 = DataField()
                        _elem221.read(iprot)
                        self.params.append(_elem221)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataType')
        if self.kind is not None:
            oprot.writeFieldBegin('kind', TType.I32, 1)
            oprot.writeI32(self.kind)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.params))
            for iter222 in self.params:
                iter222.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DataSpec(object):
    """
    Attributes:
     - schema
     - partitionColumns
     - retentionDays
     - props

    """


    def __init__(self, schema=None, partitionColumns=None, retentionDays=None, props=None,):
        self.schema = schema
        self.partitionColumns = partitionColumns
        self.retentionDays = retentionDays
        self.props = props

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.schema = TDataType()
                    self.schema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partitionColumns = []
                    (_etype226, _size223) = iprot.readListBegin()
                    for _i227 in range(_size223):
                        _elem228 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.partitionColumns.append(_elem228)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.retentionDays = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.props = {}
                    (_ktype230, _vtype231, _size229) = iprot.readMapBegin()
                    for _i233 in range(_size229):
                        _key234 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val235 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.props[_key234] = _val235
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DataSpec')
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.STRUCT, 1)
            self.schema.write(oprot)
            oprot.writeFieldEnd()
        if self.partitionColumns is not None:
            oprot.writeFieldBegin('partitionColumns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.partitionColumns))
            for iter236 in self.partitionColumns:
                oprot.writeString(iter236.encode('utf-8') if sys.version_info[0] == 2 else iter236)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.retentionDays is not None:
            oprot.writeFieldBegin('retentionDays', TType.I32, 3)
            oprot.writeI32(self.retentionDays)
            oprot.writeFieldEnd()
        if self.props is not None:
            oprot.writeFieldBegin('props', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.props))
            for kiter237, viter238 in self.props.items():
                oprot.writeString(kiter237.encode('utf-8') if sys.version_info[0] == 2 else kiter237)
                oprot.writeString(viter238.encode('utf-8') if sys.version_info[0] == 2 else viter238)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Model(object):
    """
    Attributes:
     - metaData
     - modelType
     - outputSchema
     - source
     - modelParams

    """


    def __init__(self, metaData=None, modelType=None, outputSchema=None, source=None, modelParams=None,):
        self.metaData = metaData
        self.modelType = modelType
        self.outputSchema = outputSchema
        self.source = source
        self.modelParams = modelParams

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.modelType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.outputSchema = TDataType()
                    self.outputSchema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.source = Source()
                    self.source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.modelParams = {}
                    (_ktype240, _vtype241, _size239) = iprot.readMapBegin()
                    for _i243 in range(_size239):
                        _key244 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val245 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.modelParams[_key244] = _val245
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Model')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.modelType is not None:
            oprot.writeFieldBegin('modelType', TType.I32, 2)
            oprot.writeI32(self.modelType)
            oprot.writeFieldEnd()
        if self.outputSchema is not None:
            oprot.writeFieldBegin('outputSchema', TType.STRUCT, 3)
            self.outputSchema.write(oprot)
            oprot.writeFieldEnd()
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRUCT, 4)
            self.source.write(oprot)
            oprot.writeFieldEnd()
        if self.modelParams is not None:
            oprot.writeFieldBegin('modelParams', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.modelParams))
            for kiter246, viter247 in self.modelParams.items():
                oprot.writeString(kiter246.encode('utf-8') if sys.version_info[0] == 2 else kiter246)
                oprot.writeString(viter247.encode('utf-8') if sys.version_info[0] == 2 else viter247)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Team(object):
    """
    Attributes:
     - name
     - description
     - email
     - outputNamespace
     - tableProperties
     - env
     - conf

    """


    def __init__(self, name=None, description=None, email=None, outputNamespace=None, tableProperties=None, env=None, conf=None,):
        self.name = name
        self.description = description
        self.email = email
        self.outputNamespace = outputNamespace
        self.tableProperties = tableProperties
        self.env = env
        self.conf = conf

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.email = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.outputNamespace = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.MAP:
                    self.tableProperties = {}
                    (_ktype249, _vtype250, _size248) = iprot.readMapBegin()
                    for _i252 in range(_size248):
                        _key253 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val254 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tableProperties[_key253] = _val254
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.env = ai.chronon.api.common.ttypes.EnvironmentVariables()
                    self.env.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRUCT:
                    self.conf = ai.chronon.api.common.ttypes.ConfigProperties()
                    self.conf.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Team')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 2)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 3)
            oprot.writeString(self.email.encode('utf-8') if sys.version_info[0] == 2 else self.email)
            oprot.writeFieldEnd()
        if self.outputNamespace is not None:
            oprot.writeFieldBegin('outputNamespace', TType.STRING, 10)
            oprot.writeString(self.outputNamespace.encode('utf-8') if sys.version_info[0] == 2 else self.outputNamespace)
            oprot.writeFieldEnd()
        if self.tableProperties is not None:
            oprot.writeFieldBegin('tableProperties', TType.MAP, 11)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tableProperties))
            for kiter255, viter256 in self.tableProperties.items():
                oprot.writeString(kiter255.encode('utf-8') if sys.version_info[0] == 2 else kiter255)
                oprot.writeString(viter256.encode('utf-8') if sys.version_info[0] == 2 else viter256)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.env is not None:
            oprot.writeFieldBegin('env', TType.STRUCT, 20)
            self.env.write(oprot)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.STRUCT, 21)
            self.conf.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Query)
Query.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'selects', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'wheres', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'startPartition', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'endPartition', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'timeColumn', 'UTF8', None, ),  # 5
    (6, TType.LIST, 'setups', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRING, 'mutationTimeColumn', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'reversalColumn', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'partitionColumn', 'UTF8', None, ),  # 9
)
all_structs.append(StagingQuery)
StagingQuery.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startPartition', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'setups', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'partitionColumn', 'UTF8', None, ),  # 5
    (6, TType.I32, 'engineType', None, None, ),  # 6
)
all_structs.append(EventSource)
EventSource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'topic', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'query', [Query, None], None, ),  # 3
    (4, TType.BOOL, 'isCumulative', None, None, ),  # 4
)
all_structs.append(EntitySource)
EntitySource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snapshotTable', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mutationTable', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mutationTopic', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'query', [Query, None], None, ),  # 4
)
all_structs.append(ExternalSource)
ExternalSource.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metadata', [MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'keySchema', [TDataType, None], None, ),  # 2
    (3, TType.STRUCT, 'valueSchema', [TDataType, None], None, ),  # 3
)
all_structs.append(JoinSource)
JoinSource.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'join', [Join, None], None, ),  # 1
    (2, TType.STRUCT, 'query', [Query, None], None, ),  # 2
)
all_structs.append(Source)
Source.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'events', [EventSource, None], None, ),  # 1
    (2, TType.STRUCT, 'entities', [EntitySource, None], None, ),  # 2
    (3, TType.STRUCT, 'joinSource', [JoinSource, None], None, ),  # 3
)
all_structs.append(Aggregation)
Aggregation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'inputColumn', 'UTF8', None, ),  # 1
    (2, TType.I32, 'operation', None, None, ),  # 2
    (3, TType.MAP, 'argMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'windows', (TType.STRUCT, [ai.chronon.api.common.ttypes.Window, None], False), None, ),  # 4
    (5, TType.LIST, 'buckets', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(AggregationPart)
AggregationPart.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'inputColumn', 'UTF8', None, ),  # 1
    (2, TType.I32, 'operation', None, None, ),  # 2
    (3, TType.MAP, 'argMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'window', [ai.chronon.api.common.ttypes.Window, None], None, ),  # 4
    (5, TType.STRING, 'bucket', 'UTF8', None, ),  # 5
)
all_structs.append(MetaData)
MetaData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'team', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'version', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'outputNamespace', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'additionalOutputPartitionColumns', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.MAP, 'tableProperties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.MAP, 'tags', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 20
    (21, TType.MAP, 'columnTags', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    (100, TType.BOOL, 'online', None, None, ),  # 100
    (101, TType.BOOL, 'production', None, None, ),  # 101
    (102, TType.STRING, 'sourceFile', 'UTF8', None, ),  # 102
    (103, TType.STRING, 'customJson', 'UTF8', None, ),  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    (200, TType.BOOL, 'consistencyCheck', None, None, ),  # 200
    (201, TType.DOUBLE, 'samplePercent', None, None, ),  # 201
    (202, TType.DOUBLE, 'consistencySamplePercent', None, None, ),  # 202
    (203, TType.STRUCT, 'driftSpec', [ai.chronon.observability.ttypes.DriftSpec, None], None, ),  # 203
    (204, TType.STRUCT, 'executionInfo', [ai.chronon.api.common.ttypes.ExecutionInfo, None], None, ),  # 204
)
all_structs.append(GroupBy)
GroupBy.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.LIST, 'sources', (TType.STRUCT, [Source, None], False), None, ),  # 2
    (3, TType.LIST, 'keyColumns', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'aggregations', (TType.STRUCT, [Aggregation, None], False), None, ),  # 4
    (5, TType.I32, 'accuracy', None, None, ),  # 5
    (6, TType.STRING, 'backfillStartDate', 'UTF8', None, ),  # 6
    (7, TType.LIST, 'derivations', (TType.STRUCT, [Derivation, None], False), None, ),  # 7
)
all_structs.append(JoinPart)
JoinPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'groupBy', [GroupBy, None], None, ),  # 1
    (2, TType.MAP, 'keyMapping', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'prefix', 'UTF8', None, ),  # 3
)
all_structs.append(ExternalPart)
ExternalPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'source', [ExternalSource, None], None, ),  # 1
    (2, TType.MAP, 'keyMapping', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'prefix', 'UTF8', None, ),  # 3
)
all_structs.append(Derivation)
Derivation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'expression', 'UTF8', None, ),  # 2
)
all_structs.append(Join)
Join.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'left', [Source, None], None, ),  # 2
    (3, TType.LIST, 'joinParts', (TType.STRUCT, [JoinPart, None], False), None, ),  # 3
    (4, TType.MAP, 'skewKeys', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'onlineExternalParts', (TType.STRUCT, [ExternalPart, None], False), None, ),  # 5
    (6, TType.STRUCT, 'labelParts', [LabelParts, None], None, ),  # 6
    (7, TType.LIST, 'bootstrapParts', (TType.STRUCT, [BootstrapPart, None], False), None, ),  # 7
    (8, TType.LIST, 'rowIds', (TType.STRING, 'UTF8', False), None, ),  # 8
    (9, TType.LIST, 'derivations', (TType.STRUCT, [Derivation, None], False), None, ),  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    (50, TType.BOOL, 'useLongNames', None, None, ),  # 50
)
all_structs.append(BootstrapPart)
BootstrapPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRING, 'table', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'query', [Query, None], None, ),  # 3
    (4, TType.LIST, 'keyColumns', (TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(LabelParts)
LabelParts.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'labels', (TType.STRUCT, [JoinPart, None], False), None, ),  # 1
    (2, TType.I32, 'leftStartOffset', None, None, ),  # 2
    (3, TType.I32, 'leftEndOffset', None, None, ),  # 3
    (4, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 4
)
all_structs.append(GroupByServingInfo)
GroupByServingInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'groupBy', [GroupBy, None], None, ),  # 1
    (2, TType.STRING, 'inputAvroSchema', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'selectedAvroSchema', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'keyAvroSchema', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'batchEndDate', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'dateFormat', 'UTF8', None, ),  # 6
)
all_structs.append(DataField)
DataField.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'dataType', [TDataType, None], None, ),  # 2
)
all_structs.append(TDataType)
TDataType.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'kind', None, None, ),  # 1
    (2, TType.LIST, 'params', (TType.STRUCT, [DataField, None], False), None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
)
all_structs.append(DataSpec)
DataSpec.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'schema', [TDataType, None], None, ),  # 1
    (2, TType.LIST, 'partitionColumns', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'retentionDays', None, None, ),  # 3
    (4, TType.MAP, 'props', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(Model)
Model.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.I32, 'modelType', None, None, ),  # 2
    (3, TType.STRUCT, 'outputSchema', [TDataType, None], None, ),  # 3
    (4, TType.STRUCT, 'source', [Source, None], None, ),  # 4
    (5, TType.MAP, 'modelParams', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(Team)
Team.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'description', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'email', 'UTF8', None, ),  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.STRING, 'outputNamespace', 'UTF8', None, ),  # 10
    (11, TType.MAP, 'tableProperties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.STRUCT, 'env', [ai.chronon.api.common.ttypes.EnvironmentVariables, None], None, ),  # 20
    (21, TType.STRUCT, 'conf', [ai.chronon.api.common.ttypes.ConfigProperties, None], None, ),  # 21
)
fix_spec(all_structs)
del all_structs
