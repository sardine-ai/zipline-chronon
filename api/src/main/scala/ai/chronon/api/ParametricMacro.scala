/*
 *    Copyright (C) 2023 The Chronon Authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package ai.chronon.api

import org.slf4j.Logger
import org.slf4j.LoggerFactory

import scala.collection.mutable
import scala.util.Try

// takes a map of macro names and functions and applies the functions on macro arguments
case class ParametricMacro(value: String, func: Map[String, String] => String) {
  @transient lazy val logger: Logger = LoggerFactory.getLogger(getClass)
  private val pattern = s"""\\{\\{\\s*$value(\\([\\s0-9A-Za-z_.,'\\-/=]*\\))*\\s*}}""".r

  private def parseInnerArgs(args: String): Map[String, String] = {
    val inner = args.substring(1, args.length - 1)
    val parsed = inner.split(",").foldLeft(Seq.empty[String]) { case (argSeq, token) =>
      require(token.count(_ == '=') <= 1, s"found more than one `=` sign in macro argument $token, within $argSeq")
      if (token.contains("=")) { // regular case
        argSeq :+ token
      } else if (argSeq.isEmpty && token.strip().isEmpty) { // empty arg list case
        argSeq
      } else { // csv arg case
        argSeq.tail :+ (argSeq.head + "," + token)
      }
    }
    logger.info(parsed.mkString(","))
    parsed.map(_.split("=").map(_.trim)).map(x => x(0) -> x(1)).toMap
  }

  def replace(str: String): String = {
    var startIndex = 0
    val fragments = new mutable.ArrayBuffer[String] {}
    pattern.findAllMatchIn(str) foreach { m =>
      fragments.append(str.substring(startIndex, m.start))

      val argMap = Option(m.group(1)).map { parseInnerArgs }
      val result = func(argMap.getOrElse(Map.empty[String, String]))

      fragments.append(s"'$result'")
      startIndex = m.end
    }

    fragments.append(str.substring(startIndex, str.length))
    fragments.mkString("")
  }
}

object ParametricMacro {

  private[api] def removeQuotesIfPresent(str: String): String = str.replaceAll("""^["'](.*)["']$""", "$1")

  /** @param inputDate the date to transform
    * @param partitionSpec contains utils that perform date operations
    * @param args can contain one of three keys
    *             - offset - has to be an integer,
    *                        determines how many partitions to shift the input date ahead or behind by.
    *             - lower_bound - minimum allowed partition to scan - will override offset when it leads to smaller date
    *             - upper_bound - maximum allowed partition to scan - will override offset when it leads to larger date
    * @return string applying
    */
  def adjustDate(inputDate: String, partitionSpec: PartitionSpec)(args: Map[String, String]): String = {
    var result = inputDate

    if (args.isEmpty) return inputDate

    if (args.contains("offset")) {
      val offsetTry = Try { args("offset").toInt }
      require(offsetTry.isSuccess, "offset on start_date is not an integer")
      result = partitionSpec.shift(result, offsetTry.get)
    }

    if (args.contains("lower_bound")) {
      val cleanLowerBound = removeQuotesIfPresent(args("lower_bound"))
      result = Ordering[String].max(cleanLowerBound, result)
    }

    if (args.contains("upper_bound")) {
      val upper = args("upper_bound")

      if (args.contains("lower_bound")) {
        val lower = args("lower_bound")
        require(upper >= lower, s"invalid bounds, upper bound ($upper) should be greater than lower bound ($lower)")
      }

      val cleanUpperBound = removeQuotesIfPresent(args("upper_bound"))
      result = Ordering[String].min(cleanUpperBound, result)
    }

    result
  }

  /** @param start - the start partition date of the output table generated by rendered query
    * @param end - the end partition date of the output table generated by rendered query
    * @param latest - the latest partition date
    * @param partitionSpec - represents the date format and the width of the time interval of the partition
    * @param query - the sql query with macros- eg.,
    *              select * from table
    *              where
    *                ds between {{ start_date(offset=-3, lower_bound='2025-02-01') }} AND
    *                           {{ end_date(offset=-1, lower_bound='2025-02-04') }}
    *
    * @return the rendered query with the macros substituted
    */
  def applyBasicDateMacros(start: String, end: String, latest: String, partitionSpec: PartitionSpec)(
      query: String): String = {

    val basicMacros = Array(
      ParametricMacro("start_date", ParametricMacro.adjustDate(start, partitionSpec)),
      ParametricMacro("end_date", ParametricMacro.adjustDate(end, partitionSpec)),
      ParametricMacro("latest_date", ParametricMacro.adjustDate(latest, partitionSpec))
    )

    basicMacros.foldRight(query)(_.replace(_))

  }

}
