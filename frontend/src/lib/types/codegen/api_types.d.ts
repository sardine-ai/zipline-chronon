//
// Autogenerated by Thrift Compiler (0.21.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
import Int64 = require('node-int64');


export declare enum Operation {
  MIN = 0,
  MAX = 1,
  FIRST = 2,
  LAST = 3,
  UNIQUE_COUNT = 4,
  APPROX_UNIQUE_COUNT = 5,
  COUNT = 6,
  SUM = 7,
  AVERAGE = 8,
  VARIANCE = 9,
  SKEW = 10,
  KURTOSIS = 11,
  APPROX_PERCENTILE = 12,
  LAST_K = 13,
  FIRST_K = 14,
  TOP_K = 15,
  BOTTOM_K = 16,
  HISTOGRAM = 17,
  APPROX_HISTOGRAM_K = 18,
}

export declare enum Accuracy {
  TEMPORAL = 0,
  SNAPSHOT = 1,
}

export declare enum DataKind {
  BOOLEAN = 0,
  BYTE = 1,
  SHORT = 2,
  INT = 3,
  LONG = 4,
  FLOAT = 5,
  DOUBLE = 6,
  STRING = 7,
  BINARY = 8,
  DATE = 9,
  TIMESTAMP = 10,
  MAP = 11,
  LIST = 12,
  STRUCT = 13,
}

export declare enum ModelType {
  XGBoost = 0,
  PyTorch = 1,
  TensorFlow = 2,
  ScikitLearn = 3,
  LightGBM = 4,
  Other = 100,
}

export declare class Query {
  selects?: { [k: string]: string; };
  wheres?: string[];
  startPartition?: string;
  endPartition?: string;
  timeColumn?: string;
  setups?: string[];
  mutationTimeColumn?: string;
  reversalColumn?: string;

    constructor(args?: { selects?: { [k: string]: string; }; wheres?: string[]; startPartition?: string; endPartition?: string; timeColumn?: string; setups?: string[]; mutationTimeColumn?: string; reversalColumn?: string; });
}

/**
 * Staging Query encapsulates arbitrary spark computation. One key feature is that the computation follows a
 * "fill-what's-missing" pattern. Basically instead of explicitly specifying dates you specify two macros.
 * `{{ start_date }}` and `{{end_date}}`. Chronon will pass in earliest-missing-partition for `start_date` and
 * execution-date / today for `end_date`. So the query will compute multiple partitions at once.
 */
export declare class StagingQuery {
  metaData?: MetaData;
  query?: string;
  startPartition?: string;
  setups?: string[];

    constructor(args?: { metaData?: MetaData; query?: string; startPartition?: string; setups?: string[]; });
}

export declare class EventSource {
  table?: string;
  topic?: string;
  query?: Query;
  isCumulative?: boolean;

    constructor(args?: { table?: string; topic?: string; query?: Query; isCumulative?: boolean; });
}

/**
 * Entity Sources represent data that gets mutated over-time - at row-level. This is a group of three data elements.
 * snapshotTable, mutationTable and mutationTopic. mutationTable and mutationTopic are only necessary if we are trying
 * to create realtime or point-in-time aggregations over these sources. Entity sources usually map 1:1 with a database
 * tables in your OLTP store that typically serves live application traffic. When mutation data is absent they map 1:1
 * to `dim` tables in star schema.
 */
export declare class EntitySource {
  snapshotTable?: string;
  mutationTable?: string;
  mutationTopic?: string;
  query?: Query;

    constructor(args?: { snapshotTable?: string; mutationTable?: string; mutationTopic?: string; query?: Query; });
}

export declare class ExternalSource {
  metadata?: MetaData;
  keySchema?: TDataType;
  valueSchema?: TDataType;

    constructor(args?: { metadata?: MetaData; keySchema?: TDataType; valueSchema?: TDataType; });
}

/**
 * Output of a Join can be used as input to downstream computations like GroupBy or a Join.
 * Below is a short description of each of the cases we handle.
 * Case #1: a join's source is another join [TODO]
 *   - while serving, we expect the keys for the upstream join to be passed in the request.
 *     we will query upstream first, and use the result to query downstream
 *   - while backfill, we will backfill the upstream first, and use the table as the left of the subsequent join
 *   - this is currently a "to do" because users can achieve this by themselves unlike case 2:
 * Case #2: a join is the source of another GroupBy
 *   - We will support arbitrarily long transformation chains with this.
 *   - for batch (Accuracy.SNAPSHOT), we simply backfill the join first and compute groupBy as usual
 *     - will substitute the joinSource with the resulting table and continue computation
 *     - we will add a "resolve source" step prior to backfills that will compute the parent join and update the source
 *   - for realtime (Accuracy.TEMPORAL), we need to do "stream enrichment"
 *     - we will simply issue "fetchJoin" and create an enriched source. Note the join left should be of type "events".
 * 
 */
export declare class JoinSource {
  join?: Join;
  query?: Query;

    constructor(args?: { join?: Join; query?: Query; });
}

export declare class Source {
  events?: EventSource;
  entities?: EntitySource;
  joinSource?: JoinSource;

    constructor(args?: { events?: EventSource; entities?: EntitySource; joinSource?: JoinSource; });
}

/**
 * Chronon provides a powerful aggregations primitive - that takes the familiar aggregation operation, via groupBy in
 * SQL and extends it with three things - windowing, bucketing and auto-explode.
 */
export declare class Aggregation {
  inputColumn?: string;
  operation?: Operation;
  argMap?: { [k: string]: string; };
  windows?: Window[];
  buckets?: string[];

    constructor(args?: { inputColumn?: string; operation?: Operation; argMap?: { [k: string]: string; }; windows?: Window[]; buckets?: string[]; });
}

export declare class AggregationPart {
  inputColumn?: string;
  operation?: Operation;
  argMap?: { [k: string]: string; };
  window?: Window;
  bucket?: string;

    constructor(args?: { inputColumn?: string; operation?: Operation; argMap?: { [k: string]: string; }; window?: Window; bucket?: string; });
}

export declare class MetaData {
  name?: string;
  online?: boolean;
  production?: boolean;
  customJson?: string;
  dependencies?: string[];
  tableProperties?: { [k: string]: string; };
  outputNamespace?: string;
  team?: string;
  modeToEnvMap?: { [k: string]: { [k: string]: string; }; };
  consistencyCheck?: boolean;
  samplePercent?: number;
  offlineSchedule?: string;
  consistencySamplePercent?: number;
  historicalBackfill?: boolean;
  driftSpec?: DriftSpec;

    constructor(args?: { name?: string; online?: boolean; production?: boolean; customJson?: string; dependencies?: string[]; tableProperties?: { [k: string]: string; }; outputNamespace?: string; team?: string; modeToEnvMap?: { [k: string]: { [k: string]: string; }; }; consistencyCheck?: boolean; samplePercent?: number; offlineSchedule?: string; consistencySamplePercent?: number; historicalBackfill?: boolean; driftSpec?: DriftSpec; });
}

export declare class GroupBy {
  metaData?: MetaData;
  sources?: Source[];
  keyColumns?: string[];
  aggregations?: Aggregation[];
  accuracy?: Accuracy;
  backfillStartDate?: string;
  derivations?: Derivation[];

    constructor(args?: { metaData?: MetaData; sources?: Source[]; keyColumns?: string[]; aggregations?: Aggregation[]; accuracy?: Accuracy; backfillStartDate?: string; derivations?: Derivation[]; });
}

export declare class JoinPart {
  groupBy?: GroupBy;
  keyMapping?: { [k: string]: string; };
  prefix?: string;

    constructor(args?: { groupBy?: GroupBy; keyMapping?: { [k: string]: string; }; prefix?: string; });
}

export declare class ExternalPart {
  source?: ExternalSource;
  keyMapping?: { [k: string]: string; };
  prefix?: string;

    constructor(args?: { source?: ExternalSource; keyMapping?: { [k: string]: string; }; prefix?: string; });
}

export declare class Derivation {
  name?: string;
  expression?: string;

    constructor(args?: { name?: string; expression?: string; });
}

export declare class Join {
  metaData?: MetaData;
  left?: Source;
  joinParts: JoinPart[];
  skewKeys?: { [k: string]: string[]; };
  onlineExternalParts?: ExternalPart[];
  labelParts?: LabelParts;
  bootstrapParts?: BootstrapPart[];
  rowIds?: string[];
  derivations?: Derivation[];

    constructor(args?: { metaData?: MetaData; left?: Source; joinParts: JoinPart[]; skewKeys?: { [k: string]: string[]; }; onlineExternalParts?: ExternalPart[]; labelParts?: LabelParts; bootstrapParts?: BootstrapPart[]; rowIds?: string[]; derivations?: Derivation[]; });
}

export declare class BootstrapPart {
  metaData?: MetaData;
  table?: string;
  query?: Query;
  keyColumns?: string[];

    constructor(args?: { metaData?: MetaData; table?: string; query?: Query; keyColumns?: string[]; });
}

export declare class LabelParts {
  labels?: JoinPart[];
  leftStartOffset?: number;
  leftEndOffset?: number;
  metaData?: MetaData;

    constructor(args?: { labels?: JoinPart[]; leftStartOffset?: number; leftEndOffset?: number; metaData?: MetaData; });
}

export declare class GroupByServingInfo {
  groupBy?: GroupBy;
  inputAvroSchema?: string;
  selectedAvroSchema?: string;
  keyAvroSchema?: string;
  batchEndDate?: string;
  dateFormat?: string;

    constructor(args?: { groupBy?: GroupBy; inputAvroSchema?: string; selectedAvroSchema?: string; keyAvroSchema?: string; batchEndDate?: string; dateFormat?: string; });
}

export declare class DataField {
  name?: string;
  dataType?: TDataType;

    constructor(args?: { name?: string; dataType?: TDataType; });
}

export declare class TDataType {
  kind: DataKind;
  params?: DataField[];
  name?: string;

    constructor(args?: { kind: DataKind; params?: DataField[]; name?: string; });
}

export declare class DataSpec {
  schema?: TDataType;
  partitionColumns?: string[];
  retentionDays?: number;
  props?: { [k: string]: string; };

    constructor(args?: { schema?: TDataType; partitionColumns?: string[]; retentionDays?: number; props?: { [k: string]: string; }; });
}

export declare class Model {
  metaData?: MetaData;
  modelType?: ModelType;
  outputSchema?: TDataType;
  source?: Source;
  modelParams?: { [k: string]: string; };

    constructor(args?: { metaData?: MetaData; modelType?: ModelType; outputSchema?: TDataType; source?: Source; modelParams?: { [k: string]: string; }; });
}
