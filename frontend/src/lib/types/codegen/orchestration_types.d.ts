//
// Autogenerated by Thrift Compiler (0.21.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
import Int64 = require('node-int64');


export declare enum TabularDataType {
  EVENT = 1,
  ENTITY = 2,
  CUMULATIVE_EVENTS = 3,
}

export declare enum LogicalType {
  GROUP_BY = 1,
  JOIN = 2,
  STAGING_QUERY = 3,
  MODEL = 4,
  TABULAR_DATA = 5,
}

export declare enum GroupByNodeType {
  PARTIAL_IR = 1,
  SAWTOOTH_IR = 2,
  SNAPSHOT = 3,
  PREPARE_UPLOAD = 10,
  UPLOAD = 11,
  STREAMING = 12,
}

export declare enum JoinNodeType {
  BOOTSTRAP = 1,
  RIGHT_PART = 2,
  PRE_DERIVATION = 3,
  BACKFILL = 4,
  LABEL_PART = 5,
  LABEL_JOIN = 6,
  METADATA_UPLOAD = 20,
  PREPARE_LOGS = 21,
  SUMMARIZE = 40,
  DRIFT = 41,
  DRIFT_UPLOAD = 42,
}

export declare enum StagingQueryNodeType {
  BACKFILL = 1,
}

export declare enum ModelNodeType {
  TRAINING = 300,
  BULK_INFERENCE = 301,
}

export declare enum TableNodeType {
  MATERIALIZED = 1,
  VIEW = 2,
}

export declare enum ScanStrategy {
  ALL = 0,
  LATEST = 1,
  SKIP = 2,
}

/**
 * Represents a group of structureddata assets that the same data flows through
 * just a normalized version of Events + Entity sources.
 * 
 */
export declare class TabularData {
  table?: string;
  topic?: string;
  mutationTable?: string;
  type?: TabularDataType;

    constructor(args?: { table?: string; topic?: string; mutationTable?: string; type?: TabularDataType; });
}

export declare class LogicalNode {
  stagingQuery?: StagingQuery;
  join?: Join;
  groupBy?: GroupBy;
  model?: Model;
  tabularData?: TabularData;

    constructor(args?: { stagingQuery?: StagingQuery; join?: Join; groupBy?: GroupBy; model?: Model; tabularData?: TabularData; });
}

export declare class NodeKey {
  name?: string;
  logicalType?: LogicalType;
  lineageHash?: string;

    constructor(args?: { name?: string; logicalType?: LogicalType; lineageHash?: string; });
}

export declare class NodeInfo {
  semanticHash?: string;
  confHash?: string;
  branch?: string;
  author?: string;
  conf?: LogicalNode;

    constructor(args?: { semanticHash?: string; confHash?: string; branch?: string; author?: string; conf?: LogicalNode; });
}

/**
 * First Pass
 * NodeInstance::(name, type, conf_hash) -> #[parent_nodes]
 * Node::(name, type) -> #[conf_hash]
 * 
 * Second Pass
 * Node::(name, type, compute_hash) -> #[parent_nodes]
 * 
 * different file_hashes but same lineage_hash should all go into the same orchestrator workflow
 * Node::(name, type, lineage_hash)
 * 
 */
export declare class NodeConnections {
  parents?: NodeKey[];
  children?: NodeKey[];

    constructor(args?: { parents?: NodeKey[]; children?: NodeKey[]; });
}

export declare class NodeGraph {
  connections?: any;
  infoMap?: any;

    constructor(args?: { connections?: any; infoMap?: any; });
}

export declare class PhysicalNodeType {
  groupByNodeType?: GroupByNodeType;
  joinNodeType?: JoinNodeType;
  stagingNodeType?: StagingQueryNodeType;
  modelNodeType?: ModelNodeType;
  tableNodeType?: TableNodeType;

    constructor(args?: { groupByNodeType?: GroupByNodeType; joinNodeType?: JoinNodeType; stagingNodeType?: StagingQueryNodeType; modelNodeType?: ModelNodeType; tableNodeType?: TableNodeType; });
}

/**
 * Multiple logical nodes could share the same physical node
 * For that reason we don't have a 1-1 mapping between logical and physical nodes
 * 
 */
export declare class PhysicalNodeKey {
  name?: string;
  nodeType?: PhysicalNodeType;
  lineageHash?: string;

    constructor(args?: { name?: string; nodeType?: PhysicalNodeType; lineageHash?: string; });
}

export declare class PhysicalNode {
  name?: string;
  nodeType?: PhysicalNodeType;
  lineageHash?: string;
  config?: LogicalNode;
  branch?: string;
  scheduleInterval?: Window;
  output?: Artifact;
  dependencies?: Dependency[];

    constructor(args?: { name?: string; nodeType?: PhysicalNodeType; lineageHash?: string; config?: LogicalNode; branch?: string; scheduleInterval?: Window; output?: Artifact; dependencies?: Dependency[]; });
}

export declare class PhysicalNodeInstance {
  node?: PhysicalNode;
  dependencyRanges?: any;
  outputRange?: ArtifactRange;

    constructor(args?: { node?: PhysicalNode; dependencyRanges?: any; outputRange?: ArtifactRange; });
}

export declare class Artifact {
  table?: Table;
  kvEntry?: KvEntry;

    constructor(args?: { table?: Table; kvEntry?: KvEntry; });
}

export declare class Table {
  table?: string;

    constructor(args?: { table?: string; });
}

export declare class KvEntry {
  cluster?: string;
  table?: string;
  keyAsBase64?: string;

    constructor(args?: { cluster?: string; table?: string; keyAsBase64?: string; });
}

export declare class TableRange {
  table?: Table;
  startPartition?: string;
  endPartition?: string;
  scanStrategy?: ScanStrategy;

    constructor(args?: { table?: Table; startPartition?: string; endPartition?: string; scanStrategy?: ScanStrategy; });
}

export declare class KvRange {
  kvEntry?: KvEntry;
  startMillis?: Int64;
  endMillis?: Int64;
  scanStrategy?: ScanStrategy;

    constructor(args?: { kvEntry?: KvEntry; startMillis?: Int64; endMillis?: Int64; scanStrategy?: ScanStrategy; });
}

export declare class ArtifactRange {
  tableRange?: TableRange;
  kvRange?: KvRange;

    constructor(args?: { tableRange?: TableRange; kvRange?: KvRange; });
}

export declare class KvDependency {
  kvEntry?: KvEntry;
  startOffset?: Window;
  endOffset?: Window;
  scanStrategy?: ScanStrategy;

    constructor(args?: { kvEntry?: KvEntry; startOffset?: Window; endOffset?: Window; scanStrategy?: ScanStrategy; });
}

export declare class TableDependency {
  table?: Table;
  startOffset?: Window;
  endOffset?: Window;
  startCutOff?: string;
  endCutOff?: string;
  partitionFilters?: { [k: string]: string; };
  isCumulative?: boolean;
  forceComputae?: boolean;

    constructor(args?: { table?: Table; startOffset?: Window; endOffset?: Window; startCutOff?: string; endCutOff?: string; partitionFilters?: { [k: string]: string; }; isCumulative?: boolean; forceComputae?: boolean; });
}

export declare class Dependency {
  kvDependency?: KvDependency;
  tableDependency?: TableDependency;

    constructor(args?: { kvDependency?: KvDependency; tableDependency?: TableDependency; });
}
