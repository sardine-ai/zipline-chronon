//
// Autogenerated by Thrift Compiler (0.21.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  var Int64 = require('node-int64');
}


TabularDataType = {
  '1' : 'EVENT',
  'EVENT' : 1,
  '2' : 'ENTITY',
  'ENTITY' : 2,
  '3' : 'CUMULATIVE_EVENTS',
  'CUMULATIVE_EVENTS' : 3
};
LogicalType = {
  '1' : 'GROUP_BY',
  'GROUP_BY' : 1,
  '2' : 'JOIN',
  'JOIN' : 2,
  '3' : 'STAGING_QUERY',
  'STAGING_QUERY' : 3,
  '4' : 'MODEL',
  'MODEL' : 4,
  '5' : 'TABULAR_DATA',
  'TABULAR_DATA' : 5
};
GroupByNodeType = {
  '1' : 'PARTIAL_IR',
  'PARTIAL_IR' : 1,
  '2' : 'SAWTOOTH_IR',
  'SAWTOOTH_IR' : 2,
  '3' : 'SNAPSHOT',
  'SNAPSHOT' : 3,
  '10' : 'PREPARE_UPLOAD',
  'PREPARE_UPLOAD' : 10,
  '11' : 'UPLOAD',
  'UPLOAD' : 11,
  '12' : 'STREAMING',
  'STREAMING' : 12
};
JoinNodeType = {
  '1' : 'BOOTSTRAP',
  'BOOTSTRAP' : 1,
  '2' : 'RIGHT_PART',
  'RIGHT_PART' : 2,
  '3' : 'PRE_DERIVATION',
  'PRE_DERIVATION' : 3,
  '4' : 'BACKFILL',
  'BACKFILL' : 4,
  '5' : 'LABEL_PART',
  'LABEL_PART' : 5,
  '6' : 'LABEL_JOIN',
  'LABEL_JOIN' : 6,
  '20' : 'METADATA_UPLOAD',
  'METADATA_UPLOAD' : 20,
  '21' : 'PREPARE_LOGS',
  'PREPARE_LOGS' : 21,
  '40' : 'SUMMARIZE',
  'SUMMARIZE' : 40,
  '41' : 'DRIFT',
  'DRIFT' : 41,
  '42' : 'DRIFT_UPLOAD',
  'DRIFT_UPLOAD' : 42
};
StagingQueryNodeType = {
  '1' : 'BACKFILL',
  'BACKFILL' : 1
};
ModelNodeType = {
  '300' : 'TRAINING',
  'TRAINING' : 300,
  '301' : 'BULK_INFERENCE',
  'BULK_INFERENCE' : 301
};
TableNodeType = {
  '1' : 'MATERIALIZED',
  'MATERIALIZED' : 1,
  '2' : 'VIEW',
  'VIEW' : 2
};
ScanStrategy = {
  '0' : 'ALL',
  'ALL' : 0,
  '1' : 'LATEST',
  'LATEST' : 1,
  '2' : 'SKIP',
  'SKIP' : 2
};
TabularData = function(args) {
  this.table = null;
  this.topic = null;
  this.mutationTable = null;
  this.type = null;
  if (args) {
    if (args.table !== undefined && args.table !== null) {
      this.table = args.table;
    }
    if (args.topic !== undefined && args.topic !== null) {
      this.topic = args.topic;
    }
    if (args.mutationTable !== undefined && args.mutationTable !== null) {
      this.mutationTable = args.mutationTable;
    }
    if (args.type !== undefined && args.type !== null) {
      this.type = args.type;
    }
  }
};
TabularData.prototype = {};
TabularData.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.table = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.topic = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.mutationTable = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TabularData.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('TabularData');
  if (this.table !== null && this.table !== undefined) {
    output.writeFieldBegin('table', Thrift.Type.STRING, 1);
    output.writeString(this.table);
    output.writeFieldEnd();
  }
  if (this.topic !== null && this.topic !== undefined) {
    output.writeFieldBegin('topic', Thrift.Type.STRING, 2);
    output.writeString(this.topic);
    output.writeFieldEnd();
  }
  if (this.mutationTable !== null && this.mutationTable !== undefined) {
    output.writeFieldBegin('mutationTable', Thrift.Type.STRING, 3);
    output.writeString(this.mutationTable);
    output.writeFieldEnd();
  }
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 4);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

LogicalNode = function(args) {
  this.stagingQuery = null;
  this.join = null;
  this.groupBy = null;
  this.model = null;
  this.tabularData = null;
  if (args) {
    if (args.stagingQuery !== undefined && args.stagingQuery !== null) {
      this.stagingQuery = new StagingQuery(args.stagingQuery);
    }
    if (args.join !== undefined && args.join !== null) {
      this.join = new Join(args.join);
    }
    if (args.groupBy !== undefined && args.groupBy !== null) {
      this.groupBy = new GroupBy(args.groupBy);
    }
    if (args.model !== undefined && args.model !== null) {
      this.model = new Model(args.model);
    }
    if (args.tabularData !== undefined && args.tabularData !== null) {
      this.tabularData = new TabularData(args.tabularData);
    }
  }
};
LogicalNode.prototype = {};
LogicalNode.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.stagingQuery = new StagingQuery();
        this.stagingQuery[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.join = new Join();
        this.join[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.groupBy = new GroupBy();
        this.groupBy[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.model = new Model();
        this.model[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.tabularData = new TabularData();
        this.tabularData[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

LogicalNode.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('LogicalNode');
  if (this.stagingQuery !== null && this.stagingQuery !== undefined) {
    output.writeFieldBegin('stagingQuery', Thrift.Type.STRUCT, 1);
    this.stagingQuery[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.join !== null && this.join !== undefined) {
    output.writeFieldBegin('join', Thrift.Type.STRUCT, 2);
    this.join[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.groupBy !== null && this.groupBy !== undefined) {
    output.writeFieldBegin('groupBy', Thrift.Type.STRUCT, 3);
    this.groupBy[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.model !== null && this.model !== undefined) {
    output.writeFieldBegin('model', Thrift.Type.STRUCT, 4);
    this.model[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.tabularData !== null && this.tabularData !== undefined) {
    output.writeFieldBegin('tabularData', Thrift.Type.STRUCT, 5);
    this.tabularData[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

NodeKey = function(args) {
  this.name = null;
  this.logicalType = null;
  this.lineageHash = null;
  if (args) {
    if (args.name !== undefined && args.name !== null) {
      this.name = args.name;
    }
    if (args.logicalType !== undefined && args.logicalType !== null) {
      this.logicalType = args.logicalType;
    }
    if (args.lineageHash !== undefined && args.lineageHash !== null) {
      this.lineageHash = args.lineageHash;
    }
  }
};
NodeKey.prototype = {};
NodeKey.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.logicalType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.STRING) {
        this.lineageHash = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NodeKey.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('NodeKey');
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.logicalType !== null && this.logicalType !== undefined) {
    output.writeFieldBegin('logicalType', Thrift.Type.I32, 2);
    output.writeI32(this.logicalType);
    output.writeFieldEnd();
  }
  if (this.lineageHash !== null && this.lineageHash !== undefined) {
    output.writeFieldBegin('lineageHash', Thrift.Type.STRING, 10);
    output.writeString(this.lineageHash);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

NodeInfo = function(args) {
  this.semanticHash = null;
  this.confHash = null;
  this.branch = null;
  this.author = null;
  this.conf = null;
  if (args) {
    if (args.semanticHash !== undefined && args.semanticHash !== null) {
      this.semanticHash = args.semanticHash;
    }
    if (args.confHash !== undefined && args.confHash !== null) {
      this.confHash = args.confHash;
    }
    if (args.branch !== undefined && args.branch !== null) {
      this.branch = args.branch;
    }
    if (args.author !== undefined && args.author !== null) {
      this.author = args.author;
    }
    if (args.conf !== undefined && args.conf !== null) {
      this.conf = new LogicalNode(args.conf);
    }
  }
};
NodeInfo.prototype = {};
NodeInfo.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 11:
      if (ftype == Thrift.Type.STRING) {
        this.semanticHash = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.STRING) {
        this.confHash = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 20:
      if (ftype == Thrift.Type.STRING) {
        this.branch = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 21:
      if (ftype == Thrift.Type.STRING) {
        this.author = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 30:
      if (ftype == Thrift.Type.STRUCT) {
        this.conf = new LogicalNode();
        this.conf[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NodeInfo.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('NodeInfo');
  if (this.semanticHash !== null && this.semanticHash !== undefined) {
    output.writeFieldBegin('semanticHash', Thrift.Type.STRING, 11);
    output.writeString(this.semanticHash);
    output.writeFieldEnd();
  }
  if (this.confHash !== null && this.confHash !== undefined) {
    output.writeFieldBegin('confHash', Thrift.Type.STRING, 12);
    output.writeString(this.confHash);
    output.writeFieldEnd();
  }
  if (this.branch !== null && this.branch !== undefined) {
    output.writeFieldBegin('branch', Thrift.Type.STRING, 20);
    output.writeString(this.branch);
    output.writeFieldEnd();
  }
  if (this.author !== null && this.author !== undefined) {
    output.writeFieldBegin('author', Thrift.Type.STRING, 21);
    output.writeString(this.author);
    output.writeFieldEnd();
  }
  if (this.conf !== null && this.conf !== undefined) {
    output.writeFieldBegin('conf', Thrift.Type.STRUCT, 30);
    this.conf[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

NodeConnections = function(args) {
  this.parents = null;
  this.children = null;
  if (args) {
    if (args.parents !== undefined && args.parents !== null) {
      this.parents = Thrift.copyList(args.parents, [NodeKey]);
    }
    if (args.children !== undefined && args.children !== null) {
      this.children = Thrift.copyList(args.children, [NodeKey]);
    }
  }
};
NodeConnections.prototype = {};
NodeConnections.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.parents = [];
        var _rtmp31 = input.readListBegin();
        var _size0 = _rtmp31.size || 0;
        for (var _i2 = 0; _i2 < _size0; ++_i2) {
          var elem3 = null;
          elem3 = new NodeKey();
          elem3[Symbol.for("read")](input);
          this.parents.push(elem3);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.children = [];
        var _rtmp35 = input.readListBegin();
        var _size4 = _rtmp35.size || 0;
        for (var _i6 = 0; _i6 < _size4; ++_i6) {
          var elem7 = null;
          elem7 = new NodeKey();
          elem7[Symbol.for("read")](input);
          this.children.push(elem7);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NodeConnections.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('NodeConnections');
  if (this.parents !== null && this.parents !== undefined) {
    output.writeFieldBegin('parents', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.parents.length);
    for (var iter8 in this.parents) {
      if (this.parents.hasOwnProperty(iter8)) {
        iter8 = this.parents[iter8];
        iter8[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.children !== null && this.children !== undefined) {
    output.writeFieldBegin('children', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.children.length);
    for (var iter9 in this.children) {
      if (this.children.hasOwnProperty(iter9)) {
        iter9 = this.children[iter9];
        iter9[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

NodeGraph = function(args) {
  this.connections = null;
  this.infoMap = null;
  if (args) {
    if (args.connections !== undefined && args.connections !== null) {
      this.connections = Thrift.copyMap(args.connections, [NodeConnections]);
    }
    if (args.infoMap !== undefined && args.infoMap !== null) {
      this.infoMap = Thrift.copyMap(args.infoMap, [NodeInfo]);
    }
  }
};
NodeGraph.prototype = {};
NodeGraph.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        this.connections = {};
        var _rtmp311 = input.readMapBegin();
        var _size10 = _rtmp311.size || 0;
        for (var _i12 = 0; _i12 < _size10; ++_i12) {
          if (_i12 > 0 ) {
            if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
              input.rstack.pop();
            }
          }
          var key13 = null;
          var val14 = null;
          key13 = new NodeKey();
          key13[Symbol.for("read")](input);
          val14 = new NodeConnections();
          val14[Symbol.for("read")](input);
          this.connections[key13] = val14;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.MAP) {
        this.infoMap = {};
        var _rtmp316 = input.readMapBegin();
        var _size15 = _rtmp316.size || 0;
        for (var _i17 = 0; _i17 < _size15; ++_i17) {
          if (_i17 > 0 ) {
            if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
              input.rstack.pop();
            }
          }
          var key18 = null;
          var val19 = null;
          key18 = new NodeKey();
          key18[Symbol.for("read")](input);
          val19 = new NodeInfo();
          val19[Symbol.for("read")](input);
          this.infoMap[key18] = val19;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NodeGraph.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('NodeGraph');
  if (this.connections !== null && this.connections !== undefined) {
    output.writeFieldBegin('connections', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.STRUCT, Thrift.objectLength(this.connections));
    for (var kiter20 in this.connections) {
      if (this.connections.hasOwnProperty(kiter20)) {
        var viter21 = this.connections[kiter20];
        kiter20[Symbol.for("write")](output);
        viter21[Symbol.for("write")](output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.infoMap !== null && this.infoMap !== undefined) {
    output.writeFieldBegin('infoMap', Thrift.Type.MAP, 2);
    output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.STRUCT, Thrift.objectLength(this.infoMap));
    for (var kiter22 in this.infoMap) {
      if (this.infoMap.hasOwnProperty(kiter22)) {
        var viter23 = this.infoMap[kiter22];
        kiter22[Symbol.for("write")](output);
        viter23[Symbol.for("write")](output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

PhysicalNodeType = function(args) {
  this.groupByNodeType = null;
  this.joinNodeType = null;
  this.stagingNodeType = null;
  this.modelNodeType = null;
  this.tableNodeType = null;
  if (args) {
    if (args.groupByNodeType !== undefined && args.groupByNodeType !== null) {
      this.groupByNodeType = args.groupByNodeType;
    }
    if (args.joinNodeType !== undefined && args.joinNodeType !== null) {
      this.joinNodeType = args.joinNodeType;
    }
    if (args.stagingNodeType !== undefined && args.stagingNodeType !== null) {
      this.stagingNodeType = args.stagingNodeType;
    }
    if (args.modelNodeType !== undefined && args.modelNodeType !== null) {
      this.modelNodeType = args.modelNodeType;
    }
    if (args.tableNodeType !== undefined && args.tableNodeType !== null) {
      this.tableNodeType = args.tableNodeType;
    }
  }
};
PhysicalNodeType.prototype = {};
PhysicalNodeType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.groupByNodeType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.joinNodeType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.stagingNodeType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.modelNodeType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.tableNodeType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

PhysicalNodeType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('PhysicalNodeType');
  if (this.groupByNodeType !== null && this.groupByNodeType !== undefined) {
    output.writeFieldBegin('groupByNodeType', Thrift.Type.I32, 1);
    output.writeI32(this.groupByNodeType);
    output.writeFieldEnd();
  }
  if (this.joinNodeType !== null && this.joinNodeType !== undefined) {
    output.writeFieldBegin('joinNodeType', Thrift.Type.I32, 2);
    output.writeI32(this.joinNodeType);
    output.writeFieldEnd();
  }
  if (this.stagingNodeType !== null && this.stagingNodeType !== undefined) {
    output.writeFieldBegin('stagingNodeType', Thrift.Type.I32, 3);
    output.writeI32(this.stagingNodeType);
    output.writeFieldEnd();
  }
  if (this.modelNodeType !== null && this.modelNodeType !== undefined) {
    output.writeFieldBegin('modelNodeType', Thrift.Type.I32, 4);
    output.writeI32(this.modelNodeType);
    output.writeFieldEnd();
  }
  if (this.tableNodeType !== null && this.tableNodeType !== undefined) {
    output.writeFieldBegin('tableNodeType', Thrift.Type.I32, 5);
    output.writeI32(this.tableNodeType);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

PhysicalNodeKey = function(args) {
  this.name = null;
  this.nodeType = null;
  this.lineageHash = null;
  if (args) {
    if (args.name !== undefined && args.name !== null) {
      this.name = args.name;
    }
    if (args.nodeType !== undefined && args.nodeType !== null) {
      this.nodeType = new PhysicalNodeType(args.nodeType);
    }
    if (args.lineageHash !== undefined && args.lineageHash !== null) {
      this.lineageHash = args.lineageHash;
    }
  }
};
PhysicalNodeKey.prototype = {};
PhysicalNodeKey.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.nodeType = new PhysicalNodeType();
        this.nodeType[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 20:
      if (ftype == Thrift.Type.STRING) {
        this.lineageHash = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

PhysicalNodeKey.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('PhysicalNodeKey');
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.nodeType !== null && this.nodeType !== undefined) {
    output.writeFieldBegin('nodeType', Thrift.Type.STRUCT, 2);
    this.nodeType[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.lineageHash !== null && this.lineageHash !== undefined) {
    output.writeFieldBegin('lineageHash', Thrift.Type.STRING, 20);
    output.writeString(this.lineageHash);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

PhysicalNode = function(args) {
  this.name = null;
  this.nodeType = null;
  this.lineageHash = null;
  this.config = null;
  this.branch = null;
  this.scheduleInterval = null;
  this.output = null;
  this.dependencies = null;
  if (args) {
    if (args.name !== undefined && args.name !== null) {
      this.name = args.name;
    }
    if (args.nodeType !== undefined && args.nodeType !== null) {
      this.nodeType = new PhysicalNodeType(args.nodeType);
    }
    if (args.lineageHash !== undefined && args.lineageHash !== null) {
      this.lineageHash = args.lineageHash;
    }
    if (args.config !== undefined && args.config !== null) {
      this.config = new LogicalNode(args.config);
    }
    if (args.branch !== undefined && args.branch !== null) {
      this.branch = args.branch;
    }
    if (args.scheduleInterval !== undefined && args.scheduleInterval !== null) {
      this.scheduleInterval = new Window(args.scheduleInterval);
    }
    if (args.output !== undefined && args.output !== null) {
      this.output = new Artifact(args.output);
    }
    if (args.dependencies !== undefined && args.dependencies !== null) {
      this.dependencies = Thrift.copyList(args.dependencies, [null]);
    }
  }
};
PhysicalNode.prototype = {};
PhysicalNode.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.nodeType = new PhysicalNodeType();
        this.nodeType[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 20:
      if (ftype == Thrift.Type.STRING) {
        this.lineageHash = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.config = new LogicalNode();
        this.config[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 21:
      if (ftype == Thrift.Type.STRING) {
        this.branch = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 40:
      if (ftype == Thrift.Type.STRUCT) {
        this.scheduleInterval = new Window();
        this.scheduleInterval[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 60:
      if (ftype == Thrift.Type.STRUCT) {
        this.output = new Artifact();
        this.output[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 61:
      if (ftype == Thrift.Type.LIST) {
        this.dependencies = [];
        var _rtmp325 = input.readListBegin();
        var _size24 = _rtmp325.size || 0;
        for (var _i26 = 0; _i26 < _size24; ++_i26) {
          var elem27 = null;
          elem27 = new Dependency();
          elem27[Symbol.for("read")](input);
          this.dependencies.push(elem27);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

PhysicalNode.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('PhysicalNode');
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.nodeType !== null && this.nodeType !== undefined) {
    output.writeFieldBegin('nodeType', Thrift.Type.STRUCT, 2);
    this.nodeType[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.lineageHash !== null && this.lineageHash !== undefined) {
    output.writeFieldBegin('lineageHash', Thrift.Type.STRING, 20);
    output.writeString(this.lineageHash);
    output.writeFieldEnd();
  }
  if (this.config !== null && this.config !== undefined) {
    output.writeFieldBegin('config', Thrift.Type.STRUCT, 3);
    this.config[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.branch !== null && this.branch !== undefined) {
    output.writeFieldBegin('branch', Thrift.Type.STRING, 21);
    output.writeString(this.branch);
    output.writeFieldEnd();
  }
  if (this.scheduleInterval !== null && this.scheduleInterval !== undefined) {
    output.writeFieldBegin('scheduleInterval', Thrift.Type.STRUCT, 40);
    this.scheduleInterval[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.output !== null && this.output !== undefined) {
    output.writeFieldBegin('output', Thrift.Type.STRUCT, 60);
    this.output[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.dependencies !== null && this.dependencies !== undefined) {
    output.writeFieldBegin('dependencies', Thrift.Type.LIST, 61);
    output.writeListBegin(Thrift.Type.STRUCT, this.dependencies.length);
    for (var iter28 in this.dependencies) {
      if (this.dependencies.hasOwnProperty(iter28)) {
        iter28 = this.dependencies[iter28];
        iter28[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

PhysicalNodeInstance = function(args) {
  this.node = null;
  this.dependencyRanges = null;
  this.outputRange = null;
  if (args) {
    if (args.node !== undefined && args.node !== null) {
      this.node = new PhysicalNode(args.node);
    }
    if (args.dependencyRanges !== undefined && args.dependencyRanges !== null) {
      this.dependencyRanges = Thrift.copyMap(args.dependencyRanges, [null]);
    }
    if (args.outputRange !== undefined && args.outputRange !== null) {
      this.outputRange = new ArtifactRange(args.outputRange);
    }
  }
};
PhysicalNodeInstance.prototype = {};
PhysicalNodeInstance.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.node = new PhysicalNode();
        this.node[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.MAP) {
        this.dependencyRanges = {};
        var _rtmp330 = input.readMapBegin();
        var _size29 = _rtmp330.size || 0;
        for (var _i31 = 0; _i31 < _size29; ++_i31) {
          if (_i31 > 0 ) {
            if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
              input.rstack.pop();
            }
          }
          var key32 = null;
          var val33 = null;
          key32 = new Dependency();
          key32[Symbol.for("read")](input);
          val33 = new ArtifactRange();
          val33[Symbol.for("read")](input);
          this.dependencyRanges[key32] = val33;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.outputRange = new ArtifactRange();
        this.outputRange[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

PhysicalNodeInstance.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('PhysicalNodeInstance');
  if (this.node !== null && this.node !== undefined) {
    output.writeFieldBegin('node', Thrift.Type.STRUCT, 1);
    this.node[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.dependencyRanges !== null && this.dependencyRanges !== undefined) {
    output.writeFieldBegin('dependencyRanges', Thrift.Type.MAP, 2);
    output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.STRUCT, Thrift.objectLength(this.dependencyRanges));
    for (var kiter34 in this.dependencyRanges) {
      if (this.dependencyRanges.hasOwnProperty(kiter34)) {
        var viter35 = this.dependencyRanges[kiter34];
        kiter34[Symbol.for("write")](output);
        viter35[Symbol.for("write")](output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.outputRange !== null && this.outputRange !== undefined) {
    output.writeFieldBegin('outputRange', Thrift.Type.STRUCT, 3);
    this.outputRange[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

Artifact = function(args) {
  this.table = null;
  this.kvEntry = null;
  if (args) {
    if (args.table !== undefined && args.table !== null) {
      this.table = new Table(args.table);
    }
    if (args.kvEntry !== undefined && args.kvEntry !== null) {
      this.kvEntry = new KvEntry(args.kvEntry);
    }
  }
};
Artifact.prototype = {};
Artifact.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.table = new Table();
        this.table[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.kvEntry = new KvEntry();
        this.kvEntry[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Artifact.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('Artifact');
  if (this.table !== null && this.table !== undefined) {
    output.writeFieldBegin('table', Thrift.Type.STRUCT, 1);
    this.table[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.kvEntry !== null && this.kvEntry !== undefined) {
    output.writeFieldBegin('kvEntry', Thrift.Type.STRUCT, 2);
    this.kvEntry[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

Table = function(args) {
  this.table = null;
  if (args) {
    if (args.table !== undefined && args.table !== null) {
      this.table = args.table;
    }
  }
};
Table.prototype = {};
Table.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.table = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Table.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('Table');
  if (this.table !== null && this.table !== undefined) {
    output.writeFieldBegin('table', Thrift.Type.STRING, 1);
    output.writeString(this.table);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

KvEntry = function(args) {
  this.cluster = null;
  this.table = null;
  this.keyAsBase64 = null;
  if (args) {
    if (args.cluster !== undefined && args.cluster !== null) {
      this.cluster = args.cluster;
    }
    if (args.table !== undefined && args.table !== null) {
      this.table = args.table;
    }
    if (args.keyAsBase64 !== undefined && args.keyAsBase64 !== null) {
      this.keyAsBase64 = args.keyAsBase64;
    }
  }
};
KvEntry.prototype = {};
KvEntry.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cluster = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.table = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.keyAsBase64 = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

KvEntry.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('KvEntry');
  if (this.cluster !== null && this.cluster !== undefined) {
    output.writeFieldBegin('cluster', Thrift.Type.STRING, 1);
    output.writeString(this.cluster);
    output.writeFieldEnd();
  }
  if (this.table !== null && this.table !== undefined) {
    output.writeFieldBegin('table', Thrift.Type.STRING, 2);
    output.writeString(this.table);
    output.writeFieldEnd();
  }
  if (this.keyAsBase64 !== null && this.keyAsBase64 !== undefined) {
    output.writeFieldBegin('keyAsBase64', Thrift.Type.STRING, 3);
    output.writeString(this.keyAsBase64);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

TableRange = function(args) {
  this.table = null;
  this.startPartition = null;
  this.endPartition = null;
  this.scanStrategy = null;
  if (args) {
    if (args.table !== undefined && args.table !== null) {
      this.table = new Table(args.table);
    }
    if (args.startPartition !== undefined && args.startPartition !== null) {
      this.startPartition = args.startPartition;
    }
    if (args.endPartition !== undefined && args.endPartition !== null) {
      this.endPartition = args.endPartition;
    }
    if (args.scanStrategy !== undefined && args.scanStrategy !== null) {
      this.scanStrategy = args.scanStrategy;
    }
  }
};
TableRange.prototype = {};
TableRange.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.table = new Table();
        this.table[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.startPartition = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.endPartition = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.scanStrategy = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TableRange.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('TableRange');
  if (this.table !== null && this.table !== undefined) {
    output.writeFieldBegin('table', Thrift.Type.STRUCT, 1);
    this.table[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.startPartition !== null && this.startPartition !== undefined) {
    output.writeFieldBegin('startPartition', Thrift.Type.STRING, 2);
    output.writeString(this.startPartition);
    output.writeFieldEnd();
  }
  if (this.endPartition !== null && this.endPartition !== undefined) {
    output.writeFieldBegin('endPartition', Thrift.Type.STRING, 3);
    output.writeString(this.endPartition);
    output.writeFieldEnd();
  }
  if (this.scanStrategy !== null && this.scanStrategy !== undefined) {
    output.writeFieldBegin('scanStrategy', Thrift.Type.I32, 4);
    output.writeI32(this.scanStrategy);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

KvRange = function(args) {
  this.kvEntry = null;
  this.startMillis = null;
  this.endMillis = null;
  this.scanStrategy = null;
  if (args) {
    if (args.kvEntry !== undefined && args.kvEntry !== null) {
      this.kvEntry = new KvEntry(args.kvEntry);
    }
    if (args.startMillis !== undefined && args.startMillis !== null) {
      this.startMillis = args.startMillis;
    }
    if (args.endMillis !== undefined && args.endMillis !== null) {
      this.endMillis = args.endMillis;
    }
    if (args.scanStrategy !== undefined && args.scanStrategy !== null) {
      this.scanStrategy = args.scanStrategy;
    }
  }
};
KvRange.prototype = {};
KvRange.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.kvEntry = new KvEntry();
        this.kvEntry[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.startMillis = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.endMillis = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.scanStrategy = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

KvRange.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('KvRange');
  if (this.kvEntry !== null && this.kvEntry !== undefined) {
    output.writeFieldBegin('kvEntry', Thrift.Type.STRUCT, 1);
    this.kvEntry[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.startMillis !== null && this.startMillis !== undefined) {
    output.writeFieldBegin('startMillis', Thrift.Type.I64, 2);
    output.writeI64(this.startMillis);
    output.writeFieldEnd();
  }
  if (this.endMillis !== null && this.endMillis !== undefined) {
    output.writeFieldBegin('endMillis', Thrift.Type.I64, 3);
    output.writeI64(this.endMillis);
    output.writeFieldEnd();
  }
  if (this.scanStrategy !== null && this.scanStrategy !== undefined) {
    output.writeFieldBegin('scanStrategy', Thrift.Type.I32, 4);
    output.writeI32(this.scanStrategy);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ArtifactRange = function(args) {
  this.tableRange = null;
  this.kvRange = null;
  if (args) {
    if (args.tableRange !== undefined && args.tableRange !== null) {
      this.tableRange = new TableRange(args.tableRange);
    }
    if (args.kvRange !== undefined && args.kvRange !== null) {
      this.kvRange = new KvRange(args.kvRange);
    }
  }
};
ArtifactRange.prototype = {};
ArtifactRange.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.tableRange = new TableRange();
        this.tableRange[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.kvRange = new KvRange();
        this.kvRange[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ArtifactRange.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('ArtifactRange');
  if (this.tableRange !== null && this.tableRange !== undefined) {
    output.writeFieldBegin('tableRange', Thrift.Type.STRUCT, 1);
    this.tableRange[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.kvRange !== null && this.kvRange !== undefined) {
    output.writeFieldBegin('kvRange', Thrift.Type.STRUCT, 2);
    this.kvRange[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

KvDependency = function(args) {
  this.kvEntry = null;
  this.startOffset = null;
  this.endOffset = null;
  this.scanStrategy = null;
  if (args) {
    if (args.kvEntry !== undefined && args.kvEntry !== null) {
      this.kvEntry = new KvEntry(args.kvEntry);
    }
    if (args.startOffset !== undefined && args.startOffset !== null) {
      this.startOffset = new Window(args.startOffset);
    }
    if (args.endOffset !== undefined && args.endOffset !== null) {
      this.endOffset = new Window(args.endOffset);
    }
    if (args.scanStrategy !== undefined && args.scanStrategy !== null) {
      this.scanStrategy = args.scanStrategy;
    }
  }
};
KvDependency.prototype = {};
KvDependency.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.kvEntry = new KvEntry();
        this.kvEntry[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.startOffset = new Window();
        this.startOffset[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.endOffset = new Window();
        this.endOffset[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.scanStrategy = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

KvDependency.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('KvDependency');
  if (this.kvEntry !== null && this.kvEntry !== undefined) {
    output.writeFieldBegin('kvEntry', Thrift.Type.STRUCT, 1);
    this.kvEntry[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.startOffset !== null && this.startOffset !== undefined) {
    output.writeFieldBegin('startOffset', Thrift.Type.STRUCT, 2);
    this.startOffset[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.endOffset !== null && this.endOffset !== undefined) {
    output.writeFieldBegin('endOffset', Thrift.Type.STRUCT, 3);
    this.endOffset[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.scanStrategy !== null && this.scanStrategy !== undefined) {
    output.writeFieldBegin('scanStrategy', Thrift.Type.I32, 4);
    output.writeI32(this.scanStrategy);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

TableDependency = function(args) {
  this.table = null;
  this.startOffset = null;
  this.endOffset = null;
  this.startCutOff = null;
  this.endCutOff = null;
  this.partitionFilters = null;
  this.isCumulative = null;
  this.forceComputae = null;
  if (args) {
    if (args.table !== undefined && args.table !== null) {
      this.table = new Table(args.table);
    }
    if (args.startOffset !== undefined && args.startOffset !== null) {
      this.startOffset = new Window(args.startOffset);
    }
    if (args.endOffset !== undefined && args.endOffset !== null) {
      this.endOffset = new Window(args.endOffset);
    }
    if (args.startCutOff !== undefined && args.startCutOff !== null) {
      this.startCutOff = args.startCutOff;
    }
    if (args.endCutOff !== undefined && args.endCutOff !== null) {
      this.endCutOff = args.endCutOff;
    }
    if (args.partitionFilters !== undefined && args.partitionFilters !== null) {
      this.partitionFilters = Thrift.copyMap(args.partitionFilters, [null]);
    }
    if (args.isCumulative !== undefined && args.isCumulative !== null) {
      this.isCumulative = args.isCumulative;
    }
    if (args.forceComputae !== undefined && args.forceComputae !== null) {
      this.forceComputae = args.forceComputae;
    }
  }
};
TableDependency.prototype = {};
TableDependency.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.table = new Table();
        this.table[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.startOffset = new Window();
        this.startOffset[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.endOffset = new Window();
        this.endOffset[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.startCutOff = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.endCutOff = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.MAP) {
        this.partitionFilters = {};
        var _rtmp337 = input.readMapBegin();
        var _size36 = _rtmp337.size || 0;
        for (var _i38 = 0; _i38 < _size36; ++_i38) {
          if (_i38 > 0 ) {
            if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
              input.rstack.pop();
            }
          }
          var key39 = null;
          var val40 = null;
          key39 = input.readString().value;
          val40 = input.readString().value;
          this.partitionFilters[key39] = val40;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 20:
      if (ftype == Thrift.Type.BOOL) {
        this.isCumulative = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 21:
      if (ftype == Thrift.Type.BOOL) {
        this.forceComputae = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TableDependency.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('TableDependency');
  if (this.table !== null && this.table !== undefined) {
    output.writeFieldBegin('table', Thrift.Type.STRUCT, 1);
    this.table[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.startOffset !== null && this.startOffset !== undefined) {
    output.writeFieldBegin('startOffset', Thrift.Type.STRUCT, 2);
    this.startOffset[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.endOffset !== null && this.endOffset !== undefined) {
    output.writeFieldBegin('endOffset', Thrift.Type.STRUCT, 3);
    this.endOffset[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.startCutOff !== null && this.startCutOff !== undefined) {
    output.writeFieldBegin('startCutOff', Thrift.Type.STRING, 4);
    output.writeString(this.startCutOff);
    output.writeFieldEnd();
  }
  if (this.endCutOff !== null && this.endCutOff !== undefined) {
    output.writeFieldBegin('endCutOff', Thrift.Type.STRING, 5);
    output.writeString(this.endCutOff);
    output.writeFieldEnd();
  }
  if (this.partitionFilters !== null && this.partitionFilters !== undefined) {
    output.writeFieldBegin('partitionFilters', Thrift.Type.MAP, 6);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.partitionFilters));
    for (var kiter41 in this.partitionFilters) {
      if (this.partitionFilters.hasOwnProperty(kiter41)) {
        var viter42 = this.partitionFilters[kiter41];
        output.writeString(kiter41);
        output.writeString(viter42);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.isCumulative !== null && this.isCumulative !== undefined) {
    output.writeFieldBegin('isCumulative', Thrift.Type.BOOL, 20);
    output.writeBool(this.isCumulative);
    output.writeFieldEnd();
  }
  if (this.forceComputae !== null && this.forceComputae !== undefined) {
    output.writeFieldBegin('forceComputae', Thrift.Type.BOOL, 21);
    output.writeBool(this.forceComputae);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

Dependency = function(args) {
  this.kvDependency = null;
  this.tableDependency = null;
  if (args) {
    if (args.kvDependency !== undefined && args.kvDependency !== null) {
      this.kvDependency = new KvDependency(args.kvDependency);
    }
    if (args.tableDependency !== undefined && args.tableDependency !== null) {
      this.tableDependency = new TableDependency(args.tableDependency);
    }
  }
};
Dependency.prototype = {};
Dependency.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.kvDependency = new KvDependency();
        this.kvDependency[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.tableDependency = new TableDependency();
        this.tableDependency[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Dependency.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('Dependency');
  if (this.kvDependency !== null && this.kvDependency !== undefined) {
    output.writeFieldBegin('kvDependency', Thrift.Type.STRUCT, 1);
    this.kvDependency[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.tableDependency !== null && this.tableDependency !== undefined) {
    output.writeFieldBegin('tableDependency', Thrift.Type.STRUCT, 2);
    this.tableDependency[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

